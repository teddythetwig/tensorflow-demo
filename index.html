<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpha-Omega Left Elbow Angle Tracker</title>
  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
  <!-- Load MoveNet model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
      box-sizing: border-box;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    
    .video-container {
      position: relative;
      width: 640px;
      height: 480px;
      background-color: #000;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 20px;
    }
    
    .controls-section {
      flex: 1;
      min-width: 280px;
      max-width: 350px;
      overflow-y: auto;
      max-height: 480px;
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 12px;
    }
    
    .controls-section h2 {
      font-size: 18px;
      margin: 0 0 12px 0;
      padding-bottom: 8px;
    }
    
    .controls-section h3 {
      font-size: 16px;
      margin: 0 0 8px 0;
    }
    
    .metrics {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    
    .metric {
      text-align: left;
    }
    
    .metric-label {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: bold;
    }
    
    .metric-value.in-range {
      color: #4ade80;
    }
    
    .metric-value.out-range {
      color: #fbbf24;
    }
    
    .progress-bar {
      width: 100%;
      height: 24px;
      background-color: #3a3a3a;
      border-radius: 9999px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(to right, #3b82f6, #4ade80);
      transition: width 0.3s ease-in-out;
    }
    
    .note {
      font-size: 12px;
      color: #aaa;
    }
    
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }
    
    .loading-icon {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid #fff;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #status-message {
      margin-top: 10px;
      text-align: center;
    }

    button {
      background-color: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    button:hover {
      background-color: #2563eb;
    }
    
    .joint-toggles {
      background-color: #2a2a2a;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 12px;
    }
    
    .toggle-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }
    
    .toggle-label {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      font-size: 13px;
      background-color: #333;
      border-radius: 6px;
      margin-bottom: 4px;
    }
    
    .joint-setting {
      padding: 3px 6px;
      margin-top: 1px;
      margin-bottom: 6px;
      background-color: #333;
      border-radius: 4px;
    }
    
    input[data-joint]:checked ~ .joint-setting {
      display: block;
    }
    
    .angle-control {
      margin-bottom: 4px;
    }
    
    .angle-control label {
      font-size: 12px;
      display: block;
      margin-bottom: 2px;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
    }
    
    .slider-container input[type="range"] {
      width: 100%;
      margin: 0;
    }
    
    .global-controls {
      margin: 16px auto 0;
      width: 100%;
      max-width: 600px;
    }
    
    .rep-counter-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3;
      pointer-events: none;
    }

    .current-angle {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 32px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 8px;
      font-weight: bold;
    }

    .rep-count {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 96px;
      color: white;
      background-color: rgba(59, 130, 246, 0.7);
      padding: 10px 20px;
      border-radius: 12px;
      font-weight: bold;
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
    }
    
    .tab-button {
      background-color: #333;
      color: #aaa;
      border: none;
      padding: 8px 12px;
      margin-right: 2px;
      cursor: pointer;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .tab-button:hover {
      background-color: #444;
      color: white;
    }
    
    .tab-button.active {
      background-color: #2a2a2a;
      color: white;
      border-bottom: 2px solid #3b82f6;
    }
    
    .tab-content {
      background-color: #2a2a2a;
      border-radius: 0 0 8px 8px;
      padding: 16px;
    }
    
    .tab-pane {
      display: none;
    }
    
    .tab-pane.active {
      display: block;
    }
    
    .compact-presets {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
    
    .compact-presets .preset-button {
      font-size: 12px;
      padding: 5px 8px;
    }
    
    .joint-angle-displays {
      display: none;
    }
    
    .joint-angle {
      font-size: 24px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
    }

    .joint-toggles {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .toggle-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }
    
    .toggle-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      background-color: #333;
      border-radius: 6px;
      transition: background-color 0.2s;
    }
    
    .toggle-label:hover {
      background-color: #444;
    }
    
    .toggle-label input[type="checkbox"] {
      margin-right: 8px;
      width: 16px;
      height: 16px;
    }
    
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: auto;
    }
    
    .joint-name {
      font-size: 14px;
    }
    
    .joint-settings {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 16px;
    }
    
    .angle-controls {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .angle-control {
      margin-bottom: 8px;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .slider-container input[type="range"] {
      flex: 1;
    }
    
    .slider-container input[type="number"] {
      width: 60px;
    }
    
    .compact-presets {
      display: flex;
      gap: 6px;
    }
    
    .preset-button {
      font-size: 12px;
      padding: 4px 8px;
    }

    #webcam {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transform: scaleX(-1);
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .dual-slider {
      position: relative;
      height: 16px;
      padding: 2px 0;
      margin-bottom: 2px;
    }
    
    .slider-track {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 2px;
      background: #444;
      border-radius: 1px;
    }
    
    .slider-range {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 2px;
      background: #3b82f6;
      border-radius: 1px;
    }
    
    .slider-handle {
      position: absolute;
      top: 50%;
      width: 10px;
      height: 10px;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0,0,0,0.2);
    }
    
    .slider-handle:hover {
      background: #f0f0f0;
    }
    
    .slider-handle.alpha {
      background: #4ade80;
    }
    
    .slider-handle.omega {
      background: #fb923c;
    }
    
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-bottom: 1px;
      font-size: 10px;
    }

    .joint-controls {
      width: 100%;
      max-width: 640px;
      margin-top: 20px;
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 16px;
    }
    
    h3 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 15px;
    }

    /* Style the state indicator */
    .state-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
    }
    
    /* Different colors for different states */
    .state-waiting {
      color: #f59e0b; /* Amber */
    }
    
    .state-ready {
      color: #10b981; /* Green */
    }
    
    .state-completed {
      color: #3b82f6; /* Blue */
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="video-container">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
      
      <div class="rep-counter-overlay">
        <div class="rep-count">
          <span id="rep-counter">0</span>
        </div>
        <div class="state-indicator">
          <span id="state-status">Waiting for Begin</span>
        </div>
      </div>
      
      <div id="loading" class="loading">
        <div class="loading-icon"></div>
        <p id="status-message">Loading TensorFlow.js...</p>
        <button id="start-button" style="display: none;">Start Tracking</button>
      </div>
    </div>
    
    <div class="joint-controls">
      <div class="joint-toggles">
        <h3>Select Joints to Track</h3>
        <div class="toggle-grid">
          <!-- Left Elbow -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-elbow" checked>
              <span class="joint-name">Left Elbow</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="left-elbow-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-elbow-alpha-value">160</span>°</span>
                  <span>End: <span id="left-elbow-omega-value">45</span>°</span>
                </div>
                <div class="dual-slider" id="left-elbow-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="160"></div>
                  <div class="slider-handle omega" data-value="45"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Right Elbow -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-elbow">
              <span class="joint-name">Right Elbow</span>
              <span class="color-dot" style="background-color: rgb(239, 68, 68);"></span>
            </label>
            
            <div class="joint-setting" id="right-elbow-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-elbow-alpha-value">160</span>°</span>
                  <span>End: <span id="right-elbow-omega-value">45</span>°</span>
                </div>
                <div class="dual-slider" id="right-elbow-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="160"></div>
                  <div class="slider-handle omega" data-value="45"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Left Shoulder -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-shoulder">
              <span class="joint-name">Left Shoulder</span>
              <span class="color-dot" style="background-color: rgb(16, 185, 129);"></span>
            </label>
            
            <div class="joint-setting" id="left-shoulder-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-shoulder-alpha-value">90</span>°</span>
                  <span>End: <span id="left-shoulder-omega-value">180</span>°</span>
                </div>
                <div class="dual-slider" id="left-shoulder-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="90"></div>
                  <div class="slider-handle omega" data-value="180"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Right Shoulder -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-shoulder">
              <span class="joint-name">Right Shoulder</span>
              <span class="color-dot" style="background-color: rgb(249, 115, 22);"></span>
            </label>
            
            <div class="joint-setting" id="right-shoulder-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-shoulder-alpha-value">90</span>°</span>
                  <span>End: <span id="right-shoulder-omega-value">180</span>°</span>
                </div>
                <div class="dual-slider" id="right-shoulder-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="90"></div>
                  <div class="slider-handle omega" data-value="180"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Left Knee -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-knee">
              <span class="joint-name">Left Knee</span>
              <span class="color-dot" style="background-color: rgb(139, 92, 246);"></span>
            </label>
            
            <div class="joint-setting" id="left-knee-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-knee-alpha-value">170</span>°</span>
                  <span>End: <span id="left-knee-omega-value">90</span>°</span>
                </div>
                <div class="dual-slider" id="left-knee-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="170"></div>
                  <div class="slider-handle omega" data-value="90"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Right Knee -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-knee">
              <span class="joint-name">Right Knee</span>
              <span class="color-dot" style="background-color: rgb(236, 72, 153);"></span>
            </label>
            
            <div class="joint-setting" id="right-knee-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-knee-alpha-value">170</span>°</span>
                  <span>End: <span id="right-knee-omega-value">90</span>°</span>
                </div>
                <div class="dual-slider" id="right-knee-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="170"></div>
                  <div class="slider-handle omega" data-value="90"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="global-controls">
        <div class="angle-control">
          <label for="angle-tolerance">Detection Tolerance: <span id="angle-tolerance-value">10</span>°</label>
          <div class="slider-container">
            <input type="range" id="angle-tolerance" min="1" max="30" value="10" step="1">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Joint Configuration Data Structure
    const jointConfig = {
      'left-elbow': {
        alpha: 160,
        omega: 45,
        keypoints: {
          start: 5,
          middle: 7,
          end: 9
        },
        color: 'rgb(59, 130, 246)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: true
      },
      'right-elbow': {
        alpha: 160,
        omega: 45,
        keypoints: {
          start: 6,
          middle: 8,
          end: 10
        },
        color: 'rgb(239, 68, 68)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'left-shoulder': {
        alpha: 90,
        omega: 180,
        keypoints: {
          start: 11,
          middle: 5,
          end: 7
        },
        color: 'rgb(16, 185, 129)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'right-shoulder': {
        alpha: 90,
        omega: 180,
        keypoints: {
          start: 12,
          middle: 6,
          end: 8
        },
        color: 'rgb(249, 115, 22)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'left-knee': {
        alpha: 170,
        omega: 90,
        keypoints: {
          start: 11,
          middle: 13,
          end: 15
        },
        color: 'rgb(139, 92, 246)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'right-knee': {
        alpha: 170,
        omega: 90,
        keypoints: {
          start: 12,
          middle: 14,
          end: 16
        },
        color: 'rgb(236, 72, 153)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      }
    };

    // DOM Elements
    const webcamEl = document.getElementById('webcam');
    const canvasEl = document.getElementById('canvas');
    const loadingEl = document.getElementById('loading');
    const startButtonEl = document.getElementById('start-button');
    const statusMessageEl = document.getElementById('status-message');
    const repCounterEl = document.getElementById('rep-counter');
    const jointToggles = document.querySelectorAll('input[type="checkbox"][data-joint]');
    const jointAngleDisplaysEl = document.querySelector('.joint-angle-displays');
    
    // Add variable for tolerance
    let angleTolerance = 10;
    
    // Add the tolerance control elements
    const angleToleranceSlider = document.getElementById('angle-tolerance');
    const angleToleranceValue = document.getElementById('angle-tolerance-value');
    
    // Setup tolerance control event listeners
    angleToleranceSlider.addEventListener('input', function() {
      const value = parseInt(this.value);
      angleTolerance = value;
      angleToleranceValue.textContent = value;
    });
    
    // Tracking state
    let detector;
    let smoothingFactor = 0.85;
    let positionSmoothingFactor = 0.7;
    let isRunning = false;
    let activeJoint = 'left-elbow';
    let lastValidPoseTime = 0;
    const messageDelayThreshold = 2000;
    
    // Setup joint toggle event listeners
    jointToggles.forEach(toggle => {
      const jointId = toggle.getAttribute('data-joint');
      const settingsEl = document.getElementById(`${jointId}-settings`);
      
      // Set initial state
      if (settingsEl) {
        settingsEl.style.display = toggle.checked ? 'block' : 'none';
      }
      
      // Add change event listener
      toggle.addEventListener('change', () => {
        if (settingsEl) {
          settingsEl.style.display = toggle.checked ? 'block' : 'none';
        }
        
        if (jointConfig[jointId]) {
          jointConfig[jointId].active = toggle.checked;
          updateAngleDisplays();
        }
      });
    });
    
    // Setup all range inputs using delegation and data attributes for DRY code
    document.addEventListener('input', function(e) {
      if (e.target.matches('input[type="range"][data-joint][data-param]')) {
        const joint = e.target.getAttribute('data-joint');
        const param = e.target.getAttribute('data-param');
        const value = parseInt(e.target.value);
        
        // Update the config
        jointConfig[joint][param] = value;
        
        // Update the display and number input
        document.getElementById(`${joint}-${param}-value`).textContent = value;
        document.getElementById(`${joint}-${param}-input`).value = value;
      }
    });
    
    // Setup all number inputs
    document.addEventListener('change', function(e) {
      if (e.target.matches('input[type="number"][data-joint][data-param]')) {
        const joint = e.target.getAttribute('data-joint');
        const param = e.target.getAttribute('data-param');
        let value = parseInt(e.target.value);
        
        // Validate input
        if (isNaN(value) || value < 0) {
          value = 0;
        } else if (value > 180) {
          value = 180;
        }
        
        // Update the value
        e.target.value = value;
        jointConfig[joint][param] = value;
        
        // Update the display and range input
        document.getElementById(`${joint}-${param}-value`).textContent = value;
        document.getElementById(`${joint}-${param}`).value = value;
      }
    });
    
    // Setup preset buttons
    document.addEventListener('click', function(e) {
      if (e.target.matches('.preset-button[data-joint]')) {
        const joint = e.target.getAttribute('data-joint');
        const alpha = parseInt(e.target.getAttribute('data-alpha'));
        const omega = parseInt(e.target.getAttribute('data-omega'));
        
        // Update the config
        jointConfig[joint].alpha = alpha;
        jointConfig[joint].omega = omega;
        
        // Update all UI elements
        document.getElementById(`${joint}-alpha-value`).textContent = alpha;
        document.getElementById(`${joint}-omega-value`).textContent = omega;
        document.getElementById(`${joint}-alpha`).value = alpha;
        document.getElementById(`${joint}-omega`).value = omega;
        document.getElementById(`${joint}-alpha-input`).value = alpha;
        document.getElementById(`${joint}-omega-input`).value = omega;
      }
    });
    
    // Canvas setup
    const ctx = canvasEl.getContext('2d');
    
    // Initialize the webcam
    async function setupWebcam() {
      return new Promise((resolve, reject) => {
        navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        })
        .then(stream => {
          webcamEl.srcObject = stream;
          webcamEl.onloadedmetadata = () => {
            webcamEl.width = webcamEl.videoWidth;
            webcamEl.height = webcamEl.videoHeight;
            resolve(webcamEl);
          };
        })
        .catch(error => {
          statusMessageEl.textContent = 'Error accessing webcam: ' + error.message;
          reject(error);
        });
      });
    }
    
    // Load the pose detection model - using MoveNet which is more reliable in browsers
    async function loadPoseDetectionModel() {
      try {
        // Use MoveNet SinglePose - more reliable than BlazePose in browser environments
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true
        };
        
        return await poseDetection.createDetector(model, detectorConfig);
      } catch (error) {
        console.error('Error loading model:', error);
        statusMessageEl.textContent = 'Error loading model: ' + error.message;
        throw error;
      }
    }
    
    // Calculate angle between three points
    function calculateAngle(a, b, c) {
      // Vector BA
      const ba = { x: a.x - b.x, y: a.y - b.y };
      // Vector BC
      const bc = { x: c.x - b.x, y: c.y - b.y };
      
      // Dot product and magnitudes
      const dotProduct = ba.x * bc.x + ba.y * bc.y;
      const baMagnitude = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
      const bcMagnitude = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
      
      // Cosine of angle
      const cosAngle = dotProduct / (baMagnitude * bcMagnitude);
      
      // Convert to degrees
      let angleDegrees = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
      
      return angleDegrees;
    }
    
    // Find angle in radians on the unit circle
    function getAngleRadians(x, y) {
      return Math.atan2(y, x);
    }
    
    // Check if current angle is between alpha and omega, considering direction
    function isAngleInRange(currentAngle, alpha, omega) {
      // If alpha <= omega, we're moving in the increasing direction
      if (alpha <= omega) {
        return currentAngle >= alpha && currentAngle <= omega;
      } 
      // If alpha > omega, we're moving in the decreasing direction
      else {
        return currentAngle <= alpha && currentAngle >= omega;
      }
    }
    
    // Smooth angle using exponential moving average
    function smoothAngle(currentAngle, previousSmoothedAngle, smoothingFactor) {
      return smoothingFactor * previousSmoothedAngle + (1 - smoothingFactor) * currentAngle;
    }
    
    // Helper function to check if an angle is within a certain range of a target
    function isAngleCloseToTarget(angle, target, tolerance) {
      return Math.abs(angle - target) <= tolerance;
    }
    
    // Function to update the rep counter display
    function updateRepCounter() {
      // Sum up reps from all active joints
      let totalReps = 0;
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          totalReps += jointConfig[joint].repCount;
        }
      }
      repCounterEl.textContent = totalReps;
    }
    
    // Create angle display elements for each joint
    function createAngleDisplays() {
      // Function emptied to prevent creating angle displays
      return;
    }
    
    // Update angle displays
    function updateAngleDisplays() {
      // Keep only the part that updates active status in jointConfig
      for (const joint in jointConfig) {
        const toggle = document.querySelector(`input[data-joint="${joint}"]`);
        if (toggle) {
          jointConfig[joint].active = toggle.checked;
        }
      }
      // Don't update any displays
    }
    
    // Draw angle visualization for a specific joint
    function drawAngleVisualization(ctx, joint, keypoints) {
      const config = jointConfig[joint];
      const startPoint = keypoints[config.keypoints.start];
      const middlePoint = keypoints[config.keypoints.middle];
      const endPoint = keypoints[config.keypoints.end];
      
      // Make sure all keypoints are present with good confidence
      if (startPoint && middlePoint && endPoint && 
          startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
        
        // Calculate vectors
        const vectorA = { 
          x: startPoint.x - middlePoint.x, 
          y: startPoint.y - middlePoint.y 
        };
        const vectorB = { 
          x: endPoint.x - middlePoint.x, 
          y: endPoint.y - middlePoint.y 
        };
        
        // Get the angle in radians
        const angleA = getAngleRadians(vectorA.x, vectorA.y);
        const angleB = getAngleRadians(vectorB.x, vectorB.y);
        
        // Radius for drawing arcs
        const radius = 30;
        
        // Calculate cross product to determine the direction
        const crossProduct = vectorA.x * vectorB.y - vectorA.y * vectorB.x;

        // Calculate the actual angle between vectors (0 to 180 degrees)
        const angleBetweenVectors = Math.acos(
          (vectorA.x * vectorB.x + vectorA.y * vectorB.y) / 
          (Math.sqrt(vectorA.x * vectorA.x + vectorA.y * vectorA.y) * 
           Math.sqrt(vectorB.x * vectorB.x + vectorB.y * vectorB.y))
        );

        // Determine the correct direction based on the cross product
        if (crossProduct >= 0) { // If cross product is positive, we're in the counterclockwise side
          alphaArcAngle = angleA + Math.PI * (config.alpha / 180);
          omegaArcAngle = angleA + Math.PI * (config.omega / 180);
        } else { // If cross product is negative, we're in the clockwise side
          alphaArcAngle = angleA - Math.PI * (config.alpha / 180);
          omegaArcAngle = angleA - Math.PI * (config.omega / 180);
        }
        
        // Calculate angle difference considering circle wrapping
        let angleDiff = omegaArcAngle - alphaArcAngle;
        if (angleDiff < 0) angleDiff += 2 * Math.PI;
        let isClockwise = angleDiff > Math.PI;

        
        
        // Draw target range arc
        ctx.beginPath();
        ctx.arc(
          middlePoint.x, 
          middlePoint.y, 
          radius + 20, 
          alphaArcAngle, 
          omegaArcAngle, 
          isClockwise
        );
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White with some transparency
        ctx.lineWidth = 6;
        ctx.stroke();
        
        // Draw skeleton lines with the joint's color - BOLDER LINES
        ctx.strokeStyle = config.color;
        ctx.lineWidth = 6; // Increased from 3 to 6 for bolder lines
        
        // First segment
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(middlePoint.x, middlePoint.y);
        ctx.stroke();
        
        // Second segment
        ctx.beginPath();
        ctx.moveTo(middlePoint.x, middlePoint.y);
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.stroke();
        
        // Draw joint keypoints - LARGER DOTS
        ctx.fillStyle = config.color;
        
        // Start point
        ctx.beginPath();
        ctx.arc(startPoint.x, startPoint.y, 8, 0, 2 * Math.PI); // Increased from 5 to 8
        ctx.fill();
        
        // Middle point (slightly larger)
        ctx.beginPath();
        ctx.arc(middlePoint.x, middlePoint.y, 10, 0, 2 * Math.PI); // Increased from 6 to 10
        ctx.fill();
        
        // End point
        ctx.beginPath();
        ctx.arc(endPoint.x, endPoint.y, 8, 0, 2 * Math.PI); // Increased from 5 to 8
        ctx.fill();
        
        // Draw angle text near the joint if it's active - LARGER TEXT
        if (config.active) {
          ctx.font = '48px Arial'; // Increased from 24px to 48px (2x larger)
          ctx.fillStyle = config.color;
          ctx.fillText(`${Math.round(config.smoothedAngle)}°`, middlePoint.x + 20, middlePoint.y - 20);
        }
        
        return true; // Indicate successful visualization
      }
      
      return false; // Indicate failed visualization
    }
    
    // Draw results on canvas
    function drawResults(ctx, poses, canvasWidth, canvasHeight) {
      // Clear the canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      if (!poses || poses.length === 0) {
        return; // Return early without drawing - message handling is now in detectAndRender
      }
      
      // Get the first detected pose
      const pose = poses[0];
      const keypoints = pose.keypoints;
      
      // Process each joint configured for tracking
      let successfulVisualizations = 0;
      
      for (const joint in jointConfig) {
        // Only process and visualize active joints
        if (jointConfig[joint].active) {
          const config = jointConfig[joint];
          const startPoint = keypoints[config.keypoints.start];
          const middlePoint = keypoints[config.keypoints.middle];
          const endPoint = keypoints[config.keypoints.end];
          
          // Check if we have all keypoints with good confidence
          if (startPoint && middlePoint && endPoint && 
              startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
            
            // Calculate the angle
            const angle = calculateAngle(startPoint, middlePoint, endPoint);
            
            // Store the raw angle
            config.currentAngle = angle;
            
            // Apply smoothing
            config.smoothedAngle = smoothAngle(angle, config.smoothedAngle, smoothingFactor);
            
            // Draw the visualization
            if (drawAngleVisualization(ctx, joint, keypoints)) {
              successfulVisualizations++;
            }
          }
        }
      }
      
      // If no joint was successfully visualized, show a message
      if (successfulVisualizations === 0) {
        return; // Return early without drawing - message handling is now in detectAndRender
      }
    }
    
    // Update UI elements
    function updateUI() {
      // Update angle displays for all active joints
      updateAngleDisplays();
      
      // REP COUNTING LOGIC - Process each active joint
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          const config = jointConfig[joint];
          const angle = config.smoothedAngle; // Use smoothed angle instead of raw angle
          
          const isAtAlpha = isAngleCloseToTarget(angle, config.alpha, angleTolerance);
          const isAtOmega = isAngleCloseToTarget(angle, config.omega, angleTolerance);
          
          // If we're at omega and haven't counted this rep yet, and we're ready for next rep
          if (isAtOmega && !config.hasReachedOmega && config.isReadyForNextRep) {
            config.hasReachedOmega = true;
            config.repCount++;
            updateRepCounter();
            config.isReadyForNextRep = false; // Now we need to go back to alpha
          }
          
          // If we're back at alpha after reaching omega, we're ready for the next rep
          if (isAtAlpha && config.hasReachedOmega && !config.isReadyForNextRep) {
            config.hasReachedOmega = false; // Reset for next rep
            config.isReadyForNextRep = true;
          }
        }
      }
    }
    
    // Add this function after the smoothAngle function
    function smoothKeypoints(currentKeypoints, previousKeypoints) {
      if (!previousKeypoints || !currentKeypoints) return currentKeypoints;
      
      // Create a deep copy of current keypoints to avoid modifying the original
      const smoothedKeypoints = JSON.parse(JSON.stringify(currentKeypoints));
      
      // Apply smoothing to each keypoint
      for (let i = 0; i < smoothedKeypoints.length; i++) {
        if (previousKeypoints[i] && smoothedKeypoints[i]) {
          // Only smooth if confidence is good
          if (smoothedKeypoints[i].score > 0.3) {
            smoothedKeypoints[i].x = positionSmoothingFactor * previousKeypoints[i].x + 
                                   (1 - positionSmoothingFactor) * smoothedKeypoints[i].x;
            smoothedKeypoints[i].y = positionSmoothingFactor * previousKeypoints[i].y + 
                                   (1 - positionSmoothingFactor) * smoothedKeypoints[i].y;
          }
        }
      }
      
      return smoothedKeypoints;
    }
    
    // Create a variable to store the previous keypoints
    let previousKeypoints = null;
    
    // Main detection and rendering loop
    async function detectAndRender() {
      if (!isRunning) return;
      
      try {
        // Set canvas dimensions to match video
        canvasEl.width = webcamEl.width;
        canvasEl.height = webcamEl.height;
        
        // Clear the canvas with transparent background
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        
        // Detect poses
        const poses = await detector.estimatePoses(webcamEl);
        
        // Check if any valid pose was detected
        let validPoseDetected = false;
        
        if (poses && poses.length > 0) {
          // Mirror the pose data
          poses.forEach(pose => {
            if (pose.keypoints && pose.keypoints.length > 0) {
              // Mirror the x coordinates
              pose.keypoints.forEach(keypoint => {
                keypoint.x = canvasEl.width - keypoint.x;
              });
              
              // Apply smoothing to keypoints
              pose.keypoints = smoothKeypoints(pose.keypoints, previousKeypoints);
              
              // Store current keypoints for next frame
              previousKeypoints = JSON.parse(JSON.stringify(pose.keypoints));
              
              // Check if we have enough valid keypoints for visualization
              let validKeypointsCount = 0;
              for (const joint in jointConfig) {
                if (jointConfig[joint].active) {
                  const config = jointConfig[joint];
                  const startPoint = pose.keypoints[config.keypoints.start];
                  const middlePoint = pose.keypoints[config.keypoints.middle];
                  const endPoint = pose.keypoints[config.keypoints.end];
                  
                  if (startPoint && middlePoint && endPoint && 
                      startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
                    validKeypointsCount++;
                  }
                }
              }
              
              if (validKeypointsCount > 0) {
                validPoseDetected = true;
                lastValidPoseTime = Date.now();
              }
            }
          });
        }
        
        // Now draw results and check if we need to show the message
        if (validPoseDetected) {
          drawResults(ctx, poses, canvasEl.width, canvasEl.height);
          updateUI();
        } else {
          // Check if we should show the message or keep the last pose
          const currentTime = Date.now();
          if (currentTime - lastValidPoseTime > messageDelayThreshold) {
            // Show the message if we've waited long enough
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('Position your body clearly in view', canvasEl.width / 2, canvasEl.height / 2);
          } else if (previousKeypoints) {
            // Create a fake pose with the previous keypoints to keep displaying
            const fakePose = { keypoints: previousKeypoints };
            drawResults(ctx, [fakePose], canvasEl.width, canvasEl.height);
            updateUI();
          }
        }
        
        // Continue the loop
        requestAnimationFrame(detectAndRender);
      } catch (error) {
        console.error("Error in pose detection:", error);
        statusMessageEl.textContent = "Error: " + error.message;
        stopDetection();
      }
    }
    
    // Function to stop detection
    function stopDetection() {
      isRunning = false;
      // Additional cleanup if needed
    }
    
    // Start tracking
    async function startTracking() {
      try {
        // Hide the start button and show loading
        startButtonEl.style.display = 'none';
        loadingEl.style.display = 'flex';
        statusMessageEl.textContent = 'Setting up webcam...';
        
        // Setup webcam
        await setupWebcam();
        
        // Load pose model
        statusMessageEl.textContent = 'Loading pose detection model...';
        detector = await loadPoseDetectionModel();
        
        // Hide loading screen, show webcam
        loadingEl.style.display = 'none';
        webcamEl.style.display = 'block'; // Make sure webcam is visible
        
        // Create initial angle displays
        createAngleDisplays();
        
        // Start the detection loop
        isRunning = true;
        detectAndRender();
      } catch (error) {
        console.error('Error starting tracking:', error);
        statusMessageEl.textContent = 'Error starting tracking: ' + error.message;
        startButtonEl.style.display = 'block';
      }
    }
    
    // Initialize the app
    async function init() {
      try {
        // Check if TensorFlow.js is available
        if (typeof tf === 'undefined') {
          statusMessageEl.textContent = 'TensorFlow.js not loaded. Check your internet connection.';
          return;
        }
        
        // Show start button
        statusMessageEl.textContent = 'Ready to start. Click the button below.';
        startButtonEl.style.display = 'block';
        startButtonEl.addEventListener('click', startTracking);
        
        // Initialize rep counter
        updateRepCounter();
      } catch (error) {
        console.error('Initialization error:', error);
        statusMessageEl.textContent = 'Initialization error: ' + error.message;
      }
    }
    
    // Start when page is loaded
    window.onload = init;

    // Add this to your existing JavaScript
    function initializeDualSliders() {
      document.querySelectorAll('.dual-slider').forEach(slider => {
        const track = slider.querySelector('.slider-track');
        const range = slider.querySelector('.slider-range');
        const handles = slider.querySelectorAll('.slider-handle');
        const joint = slider.id.split('-slider')[0];
        
        let activeHandle = null;
        
        function updateSlider(handle, value) {
          const percent = (value / 180) * 100;
          handle.style.left = `${percent}%`;
          handle.dataset.value = value;
          
          // Update range bar
          const alpha = parseInt(handles[0].dataset.value);
          const omega = parseInt(handles[1].dataset.value);
          const left = Math.min(alpha, omega) / 180 * 100;
          const right = Math.max(alpha, omega) / 180 * 100;
          range.style.left = `${left}%`;
          range.style.width = `${right - left}%`;
          
          // Update value displays
          document.getElementById(`${joint}-alpha-value`).textContent = Math.round(alpha);
          document.getElementById(`${joint}-omega-value`).textContent = Math.round(omega);
          
          // Update joint config
          if (jointConfig[joint]) {
            if (handle.classList.contains('alpha')) {
              jointConfig[joint].alpha = value;
            } else {
              jointConfig[joint].omega = value;
            }
          }
        }
        
        handles.forEach(handle => {
          handle.addEventListener('mousedown', e => {
            e.preventDefault(); // Prevent text selection
            activeHandle = handle;
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', () => {
              activeHandle = null;
              document.removeEventListener('mousemove', handleDrag);
            });
          });
        });
        
        function handleDrag(e) {
          if (!activeHandle) return;
          
          const rect = track.getBoundingClientRect();
          let value = ((e.clientX - rect.left) / rect.width) * 180;
          value = Math.max(0, Math.min(180, value));
          updateSlider(activeHandle, value);
        }
        
        // Initialize positions
        handles.forEach(handle => {
          updateSlider(handle, parseInt(handle.dataset.value));
        });
      });
    }

    // Call this after your page loads
    document.addEventListener('DOMContentLoaded', () => {
      initializeDualSliders();
    });

    // Create a single global rep counter
    let globalRepCount = 0;

    // Update the rep counting mechanism
    let repState = {
      allJointsReady: false,
      allJointsCompleted: false,
      lastRepTime: 0 // Track time of last rep for debouncing
    };

    // Make sure jointConfig initialization doesn't include per-joint rep counts
    function initializeJointConfig() {
      // For each joint in the config
      for (const joint in jointConfig) {
        // Make sure both state flags are properly initialized
        jointConfig[joint].isReadyForNextRep = false; // Start as not ready
        jointConfig[joint].hasReachedOmega = false;
        // Remove individual joint rep counts
        if (jointConfig[joint].hasOwnProperty('repCount')) {
          delete jointConfig[joint].repCount;
        }
      }
    }

    // Initialize the rep counter display
    function updateRepCounter() {
      document.getElementById('rep-counter').textContent = globalRepCount;
    }

    // Update the rep counting function to maintain state correctly
    function updateRepCount() {
      // Get all active joints
      const activeJoints = Object.keys(jointConfig).filter(joint => jointConfig[joint].active);
      
      if (activeJoints.length === 0) {
        // No active joints
        document.getElementById('state-status').textContent = "No joints selected";
        return;
      }
      
      // Check if all joints are at their Begin position (alpha)
      const allAtBegin = activeJoints.every(joint => {
        const angle = jointConfig[joint].smoothedAngle;
        return isAngleCloseToTarget(angle, jointConfig[joint].alpha, angleTolerance);
      });
      
      // Check if all joints are at their End position (omega)
      const allAtEnd = activeJoints.every(joint => {
        const angle = jointConfig[joint].smoothedAngle;
        return isAngleCloseToTarget(angle, jointConfig[joint].omega, angleTolerance);
      });
      
      // STATE MACHINE:
      
      // PHASE 1: Wait for all joints to reach Begin position
      if (allAtBegin && !repState.allJointsReady && !repState.allJointsCompleted) {
        repState.allJointsReady = true;
        console.log("All joints at BEGIN position - ready for rep");
      }
      
      // PHASE 2: All joints were at Begin, now all are at End - COUNT REP
      if (allAtEnd && repState.allJointsReady && !repState.allJointsCompleted) {
        const now = Date.now();
        if (now - repState.lastRepTime > 500) { // Debounce
          // Increment the global rep counter
          globalRepCount++;
          updateRepCounter();
          
          // Mark as completed
          repState.allJointsCompleted = true;
          repState.lastRepTime = now;
          console.log("Rep counted!");
        }
      }
      
      // PHASE 3: After counting a rep, wait for all joints to return to Begin before allowing next rep
      if (allAtBegin && repState.allJointsCompleted) {
        // Reset for next rep cycle
        repState.allJointsReady = true;
        repState.allJointsCompleted = false;
        console.log("Reset for next rep");
      }
      
      // Once we're in the ready state, we stay there until completion
      // We'll only reset to waiting if explicitly required
      
      // Update the state display
      updateStateDisplay();
    }

    // Make sure the rep counter is initialized on page load
    document.addEventListener('DOMContentLoaded', function() {
      initializeJointConfig();
      globalRepCount = 0;
      updateRepCounter();
      // ... other initialization code ...
    });

    // Reset button functionality if you have one
    function resetRepCounter() {
      globalRepCount = 0;
      updateRepCounter();
    }

    // Add function to update the state display
    function updateStateDisplay() {
      const stateElement = document.getElementById('state-status');
      
      if (!stateElement) return;
      
      // Remove all state classes
      stateElement.classList.remove('state-waiting', 'state-ready', 'state-completed');
      
      // Set appropriate state message and class
      if (!repState.allJointsReady && !repState.allJointsCompleted) {
        stateElement.textContent = "Waiting for Begin";
        stateElement.classList.add('state-waiting');
      } 
      else if (repState.allJointsReady && !repState.allJointsCompleted) {
        stateElement.textContent = "Ready - Go to End";
        stateElement.classList.add('state-ready');
      }
      else if (repState.allJointsCompleted) {
        stateElement.textContent = "Completed - Return to Begin";
        stateElement.classList.add('state-completed');
      }
    }

    // Alternatively, if you can't directly edit the above function, find where angles are updated
    // and add the rep counter call there

    // Another approach: hook into the rendering loop
    function hookIntoRenderLoop() {
      const originalRenderFunction = window.requestAnimationFrame;
      
      window.requestAnimationFrame = function(callback) {
        return originalRenderFunction.call(window, function(timestamp) {
          // Call the original callback
          callback(timestamp);
          
          // Then call our rep counter update
          updateRepCount();
        });
      };
    }

    // Or, set up a separate loop for the rep counter
    function startRepCounterLoop() {
      setInterval(updateRepCount, 100); // Check rep state 10 times per second
    }

    // Add this to your initialization code
    document.addEventListener('DOMContentLoaded', function() {
      // ... existing initialization ...
      
      // Choose one of these methods to ensure updateRepCount is called:
      // hookIntoRenderLoop();
      startRepCounterLoop();
    });
  </script>
</body>
</html>