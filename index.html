<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpha-Omega Left Elbow Angle Tracker</title>
  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
  <!-- Load MoveNet model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: white;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      margin-bottom: 20px;
      aspect-ratio: 4/3;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    #webcam {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      background-color: #000;
      z-index: 1;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      background-color: transparent;
    }
    
    .controls {
      background-color: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
    }
    
    .controls h3 {
      margin-top: 0;
      margin-bottom: 16px;
      font-size: 18px;
    }
    
    .metrics {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    
    .metric {
      text-align: left;
    }
    
    .metric-label {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: bold;
    }
    
    .metric-value.in-range {
      color: #4ade80;
    }
    
    .metric-value.out-range {
      color: #fbbf24;
    }
    
    .progress-bar {
      width: 100%;
      height: 24px;
      background-color: #3a3a3a;
      border-radius: 9999px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(to right, #3b82f6, #4ade80);
      transition: width 0.3s ease-in-out;
    }
    
    .note {
      font-size: 12px;
      color: #aaa;
    }
    
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 300px;
      background-color: #1a1a1a;
      margin-bottom: 20px;
      border-radius: 8px;
    }
    
    .loading-icon {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid #fff;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #status-message {
      margin-top: 10px;
      text-align: center;
    }

    button {
      background-color: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    button:hover {
      background-color: #2563eb;
    }
    
    .angle-controls {
      background-color: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
      margin-bottom: 16px;
    }
    
    .angle-control {
      margin-bottom: 10px;
    }
    
    .angle-control label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
    }
    
    .slider-container input[type="range"] {
      flex-grow: 1;
      margin-right: 10px;
    }
    
    .slider-container input[type="number"] {
      width: 60px;
      background-color: #3a3a3a;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 5px;
    }
    
    .presets {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    
    .preset-button {
      background-color: #3a3a3a;
      border: 1px solid #555;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .preset-button:hover {
      background-color: #4a4a4a;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Alpha-Omega Left Elbow Angle Tracker</h2>
    
    <!-- Angle Range Controls -->
    <div class="angle-controls">
      <h3>Movement Range Settings</h3>
      
      <div class="angle-control">
        <label for="alpha-angle">Alpha (Starting Angle): <span id="alpha-angle-value">160</span>°</label>
        <div class="slider-container">
          <input type="range" id="alpha-angle" min="0" max="180" value="160" step="1">
          <input type="number" id="alpha-angle-input" min="0" max="180" value="160">
        </div>
      </div>
      
      <div class="angle-control">
        <label for="omega-angle">Omega (Ending Angle): <span id="omega-angle-value">45</span>°</label>
        <div class="slider-container">
          <input type="range" id="omega-angle" min="0" max="180" value="45" step="1">
          <input type="number" id="omega-angle-input" min="0" max="180" value="45">
        </div>
      </div>
      
      <div class="angle-control">
        <label for="angle-tolerance">Rep Detection Tolerance: <span id="angle-tolerance-value">10</span>°</label>
        <div class="slider-container">
          <input type="range" id="angle-tolerance" min="1" max="30" value="10" step="1">
          <input type="number" id="angle-tolerance-input" min="1" max="30" value="10">
        </div>
      </div>
      
      <div class="presets">
        <button class="preset-button" data-alpha="30" data-omega="90">Flex to 90° (30°→90°)</button>
        <button class="preset-button" data-alpha="90" data-omega="45">Flex from 90° (90°→45°)</button>
        <button class="preset-button" data-alpha="90" data-omega="160">Extend from 90° (90°→160°)</button>
        <button class="preset-button" data-alpha="45" data-omega="120">Wide Range (45°→120°)</button>
        <button class="preset-button" data-alpha="120" data-omega="45">Reverse Direction (120°→45°)</button>
      </div>
    </div>
    
    <div id="loading" class="loading">
      <div class="loading-icon"></div>
      <p id="status-message">Loading TensorFlow.js...</p>
      <button id="start-button" style="display: none;">Start Tracking</button>
    </div>
    
    <div class="video-container">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
    </div>
    
    <div class="controls">
      <h3>Elbow Movement Tracker</h3>
      
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Current Angle</div>
          <div id="current-angle" class="metric-value">0°</div>
        </div>
        
        <div class="metric">
          <div class="metric-label">Status</div>
          <div id="status" class="metric-value out-range">Outside Target Range</div>
        </div>
        
        <div class="metric">
          <div class="metric-label">Target Movement</div>
          <div id="target-range" class="metric-value">160° → 45°</div>
        </div>
        
        <div class="metric">
          <div class="metric-label">Reps Completed</div>
          <div id="rep-counter" class="metric-value">0</div>
        </div>
      </div>
      
      <div class="progress-bar">
        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
      </div>
      
      <p class="note">Move your left arm between the Alpha and Omega angles. Stay within the blue target arc.</p>
    </div>
  </div>

  <script>
    // DOM Elements
    const webcamEl = document.getElementById('webcam');
    const canvasEl = document.getElementById('canvas');
    const loadingEl = document.getElementById('loading');
    const startButtonEl = document.getElementById('start-button');
    const statusMessageEl = document.getElementById('status-message');
    const currentAngleEl = document.getElementById('current-angle');
    const statusEl = document.getElementById('status');
    const targetRangeEl = document.getElementById('target-range');
    const progressFillEl = document.getElementById('progress-fill');
    
    // Angle control elements
    const alphaAngleSlider = document.getElementById('alpha-angle');
    const omegaAngleSlider = document.getElementById('omega-angle');
    const alphaAngleInput = document.getElementById('alpha-angle-input');
    const omegaAngleInput = document.getElementById('omega-angle-input');
    const alphaAngleValue = document.getElementById('alpha-angle-value');
    const omegaAngleValue = document.getElementById('omega-angle-value');
    const presetButtons = document.querySelectorAll('.preset-button');
    
    // Add variable for tolerance
    let angleTolerance = 10; // Default tolerance in degrees
    
    // Add the tolerance control elements
    const angleToleranceSlider = document.getElementById('angle-tolerance');
    const angleToleranceInput = document.getElementById('angle-tolerance-input');
    const angleToleranceValue = document.getElementById('angle-tolerance-value');
    
    // Setup tolerance control event listeners
    angleToleranceSlider.addEventListener('input', function() {
      const value = parseInt(this.value);
      angleTolerance = value;
      angleToleranceValue.textContent = value;
      angleToleranceInput.value = value;
    });
    
    angleToleranceInput.addEventListener('change', function() {
      const value = parseInt(this.value);
      
      // Validate input
      if (isNaN(value) || value < 1) {
        this.value = 1;
        angleTolerance = 1;
      } else if (value > 30) {
        this.value = 30;
        angleTolerance = 30;
      } else {
        angleTolerance = value;
      }
      
      angleToleranceSlider.value = angleTolerance;
      angleToleranceValue.textContent = angleTolerance;
    });
    
    // Tracking state
    let detector;
    let elbowAngle = 0;
    let inTargetRange = false;
    let isRunning = false;
    
    // Define target angle range (alpha to omega)
    let alphaAngle = 160; // Starting angle
    let omegaAngle = 45; // Ending angle
    
    // Update target range display
    function updateTargetRangeDisplay() {
      targetRangeEl.textContent = `${alphaAngle}° → ${omegaAngle}°`;
    }
    
    updateTargetRangeDisplay();
    
    // Setup angle control event listeners
    alphaAngleSlider.addEventListener('input', function() {
      const value = parseInt(this.value);
      alphaAngle = value;
      alphaAngleValue.textContent = value;
      alphaAngleInput.value = value;
      
      updateTargetRangeDisplay();
    });
    
    omegaAngleSlider.addEventListener('input', function() {
      const value = parseInt(this.value);
      omegaAngle = value;
      omegaAngleValue.textContent = value;
      omegaAngleInput.value = value;
      
      updateTargetRangeDisplay();
    });
    
    alphaAngleInput.addEventListener('change', function() {
      const value = parseInt(this.value);
      
      // Validate input
      if (isNaN(value) || value < 0) {
        this.value = 0;
        alphaAngle = 0;
      } else if (value > 180) {
        this.value = 180;
        alphaAngle = 180;
      } else {
        alphaAngle = value;
      }
      
      alphaAngleSlider.value = alphaAngle;
      alphaAngleValue.textContent = alphaAngle;
      
      updateTargetRangeDisplay();
    });
    
    omegaAngleInput.addEventListener('change', function() {
      const value = parseInt(this.value);
      
      // Validate input
      if (isNaN(value) || value < 0) {
        this.value = 0;
        omegaAngle = 0;
      } else if (value > 180) {
        this.value = 180;
        omegaAngle = 180;
      } else {
        omegaAngle = value;
      }
      
      omegaAngleSlider.value = omegaAngle;
      omegaAngleValue.textContent = omegaAngle;
      
      updateTargetRangeDisplay();
    });
    
    // Setup preset buttons
    presetButtons.forEach(button => {
      button.addEventListener('click', function() {
        const alpha = parseInt(this.getAttribute('data-alpha'));
        const omega = parseInt(this.getAttribute('data-omega'));
        
        alphaAngle = alpha;
        omegaAngle = omega;
        
        alphaAngleSlider.value = alpha;
        omegaAngleSlider.value = omega;
        alphaAngleInput.value = alpha;
        omegaAngleInput.value = omega;
        alphaAngleValue.textContent = alpha;
        omegaAngleValue.textContent = omega;
        
        updateTargetRangeDisplay();
      });
    });
    
    // Canvas setup
    const ctx = canvasEl.getContext('2d');
    
    // Initialize the webcam
    async function setupWebcam() {
      return new Promise((resolve, reject) => {
        navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        })
        .then(stream => {
          webcamEl.srcObject = stream;
          webcamEl.onloadedmetadata = () => {
            webcamEl.width = webcamEl.videoWidth;
            webcamEl.height = webcamEl.videoHeight;
            resolve(webcamEl);
          };
        })
        .catch(error => {
          statusMessageEl.textContent = 'Error accessing webcam: ' + error.message;
          reject(error);
        });
      });
    }
    
    // Load the pose detection model - using MoveNet which is more reliable in browsers
    async function loadPoseDetectionModel() {
      try {
        // Use MoveNet SinglePose - more reliable than BlazePose in browser environments
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true
        };
        
        return await poseDetection.createDetector(model, detectorConfig);
      } catch (error) {
        console.error('Error loading model:', error);
        statusMessageEl.textContent = 'Error loading model: ' + error.message;
        throw error;
      }
    }
    
    // Calculate angle between three points
    function calculateAngle(a, b, c) {
      // Vector BA
      const ba = { x: a.x - b.x, y: a.y - b.y };
      // Vector BC
      const bc = { x: c.x - b.x, y: c.y - b.y };
      
      // Dot product and magnitudes
      const dotProduct = ba.x * bc.x + ba.y * bc.y;
      const baMagnitude = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
      const bcMagnitude = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
      
      // Cosine of angle
      const cosAngle = dotProduct / (baMagnitude * bcMagnitude);
      
      // Convert to degrees
      let angleDegrees = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
      
      return angleDegrees;
    }
    
    // Find angle in radians on the unit circle
    function getAngleRadians(x, y) {
      return Math.atan2(y, x);
    }
    
    // Check if current angle is between alpha and omega, considering direction
    function isAngleInRange(currentAngle, alpha, omega) {
      // If alpha <= omega, we're moving in the increasing direction
      if (alpha <= omega) {
        return currentAngle >= alpha && currentAngle <= omega;
      } 
      // If alpha > omega, we're moving in the decreasing direction
      else {
        return currentAngle <= alpha && currentAngle >= omega;
      }
    }
    
    // Get progress percentage between alpha and omega
    function getProgressPercentage(currentAngle, alpha, omega) {
      // Get the distance between alpha and omega (handle wrap-around)
      const totalDistance = Math.abs(omega - alpha);
      if (totalDistance === 0) return 100; // Avoid division by zero
      
      // Get the distance traveled from alpha to current
      let distanceTraveled;
      if (alpha <= omega) {
        // Moving in increasing direction
        distanceTraveled = Math.max(0, Math.min(totalDistance, currentAngle - alpha));
      } else {
        // Moving in decreasing direction
        distanceTraveled = Math.max(0, Math.min(totalDistance, alpha - currentAngle));
      }
      
      // Calculate percentage
      return (distanceTraveled / totalDistance) * 100;
    }
    
    // Draw angle visualization
    function drawAngleVisualization(ctx, shoulder, elbow, wrist, angle) {
      // Calculate vectors
      const upperArmVector = { 
        x: shoulder.x - elbow.x, 
        y: shoulder.y - elbow.y 
      };
      const forearmVector = { 
        x: wrist.x - elbow.x, 
        y: wrist.y - elbow.y 
      };
      
      // Get the angle of upper arm and forearm in radians
      // The target range arc is relative to the angle of the upper arm
      const upperArmAngle = getAngleRadians(upperArmVector.x, upperArmVector.y);
      const forearmAngle = getAngleRadians(forearmVector.x, forearmVector.y);
      
      // Radius for drawing arcs
      const radius = 50;
      
      // Calculate where the forearm would be at alpha and omega angles
      // The mapping is from anatomical angle (0-180°) to forearm position relative to upper arm
      // Convert anatomical angles to arc angles
      // 180° elbow angle = upperArmAngle + π (straight arm)
      // 0° elbow angle = upperArmAngle (fully bent arm)(arm folded in on itself somehow)

      // Change the alpha and omega angles into the coordinate system where the upper arm is at 0 degrees
      // This is because the upper arm is the reference frame for the target range arc
      const alphaArcAngle = upperArmAngle + Math.PI * (alphaAngle / 180);
      const omegaArcAngle = upperArmAngle + Math.PI * (omegaAngle / 180);

      
      // Draw target range arc - determining the correct direction
      // We need to decide which way to draw the arc (clockwise or counterclockwise)
      // to ensure we're drawing the interior angle
      
      // Calculate angle difference considering the circle wrapping
      let angleDiff = omegaArcAngle - alphaArcAngle;
      if (angleDiff < 0) angleDiff += 2 * Math.PI;
      let isClockwise = angleDiff > Math.PI;
      
      // Draw target range arc
      ctx.beginPath();
      ctx.arc(
        elbow.x, 
        elbow.y, 
        radius + 10, 
        alphaArcAngle, 
        omegaArcAngle, 
        isClockwise
      );
      ctx.strokeStyle = 'rgba(100, 100, 255, 0.6)';
      ctx.lineWidth = 10;
      ctx.stroke();
      
      // Draw angle text
      ctx.font = '20px Arial';
      ctx.fillStyle = 'white';
      ctx.fillText(`${Math.round(angle)}°`, elbow.x + 20, elbow.y - 20);
      
      // Calculate positions for alpha/omega labels
      let alphaTextPos = {
        x: elbow.x + (radius + 30) * Math.cos(alphaArcAngle),
        y: elbow.y + (radius + 30) * Math.sin(alphaArcAngle)
      };
      
      let omegaTextPos = {
        x: elbow.x + (radius + 30) * Math.cos(omegaArcAngle),
        y: elbow.y + (radius + 30) * Math.sin(omegaArcAngle)
      };
      
      ctx.font = '16px Arial';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.fillText(`α: ${alphaAngle}°`, alphaTextPos.x, alphaTextPos.y);
      ctx.fillText(`ω: ${omegaAngle}°`, omegaTextPos.x, omegaTextPos.y);
    }
    
    // Draw results on canvas
    function drawResults(ctx, poses, canvasWidth, canvasHeight) {
      // Clear the canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      if (!poses || poses.length === 0) {
        ctx.font = '24px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText('No poses detected. Make sure your body is visible.', canvasWidth / 2, canvasHeight / 2);
        return;
      }
      
      // Get the first detected pose
      const pose = poses[0];
      
      // MoveNet uses different keypoint indices
      // For MoveNet: 5=right_shoulder, 7=right_elbow, 9=right_wrist
      const keypoints = pose.keypoints;
      
      const shoulder = keypoints[5];
      const elbow = keypoints[7];
      const wrist = keypoints[9];
      
      // Check if we have all the points we need with good confidence
      if (shoulder && elbow && wrist && 
          shoulder.score > 0.3 && elbow.score > 0.3 && wrist.score > 0.3) {
        
        // Calculate the elbow angle
        elbowAngle = calculateAngle(shoulder, elbow, wrist);
        inTargetRange = isAngleInRange(elbowAngle, alphaAngle, omegaAngle);
        
        // Draw skeleton
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 4;
        
        // Upper arm
        ctx.beginPath();
        ctx.moveTo(shoulder.x, shoulder.y);
        ctx.lineTo(elbow.x, elbow.y);
        ctx.stroke();
        
        // Forearm
        ctx.beginPath();
        ctx.moveTo(elbow.x, elbow.y);
        ctx.lineTo(wrist.x, wrist.y);
        ctx.stroke();
        
        // Draw joints
        ctx.fillStyle = 'red';
        
        // Shoulder joint
        ctx.beginPath();
        ctx.arc(shoulder.x, shoulder.y, 8, 0, 2 * Math.PI);
        ctx.fill();
        
        // Elbow joint
        ctx.beginPath();
        ctx.arc(elbow.x, elbow.y, 8, 0, 2 * Math.PI);
        ctx.fill();
        
        // Wrist joint
        ctx.beginPath();
        ctx.arc(wrist.x, wrist.y, 8, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw angle visualization
        drawAngleVisualization(ctx, shoulder, elbow, wrist, elbowAngle);
      } else {
        ctx.font = '24px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText('Position your left arm clearly in view', canvasWidth / 2, canvasHeight / 2);
      }
    }
    
    // Update UI elements
    function updateUI() {
      // Update angle display
      currentAngleEl.textContent = `${Math.round(elbowAngle)}°`;
      
      // Update status
      if (inTargetRange) {
        statusEl.textContent = 'In Target Range';
        statusEl.classList.remove('out-range');
        statusEl.classList.add('in-range');
      } else {
        statusEl.textContent = 'Outside Target Range';
        statusEl.classList.remove('in-range');
        statusEl.classList.add('out-range');
      }
      
      // Update progress bar based on movement from alpha to omega
      const progressPercentage = getProgressPercentage(elbowAngle, alphaAngle, omegaAngle);
      progressFillEl.style.width = `${progressPercentage}%`;
      
      // REP COUNTING LOGIC
      const isAtAlpha = isAngleCloseToTarget(elbowAngle, alphaAngle, angleTolerance); // Use variable tolerance
      const isAtOmega = isAngleCloseToTarget(elbowAngle, omegaAngle, angleTolerance); // Use variable tolerance
      
      // If we're at omega and haven't counted this rep yet, and we're ready for next rep
      if (isAtOmega && !hasReachedOmega && isReadyForNextRep) {
        hasReachedOmega = true;
        repCount++;
        updateRepCounter();
        isReadyForNextRep = false; // Now we need to go back to alpha
      }
      
      // If we're back at alpha after reaching omega, we're ready for the next rep
      if (isAtAlpha && hasReachedOmega && !isReadyForNextRep) {
        isReadyForNextRep = true;
        hasReachedOmega = false; // Reset for next rep
      }
    }
    
    // Main detection and rendering loop
    async function detectAndRender() {
      if (!isRunning) return;
      
      try {
        // Set canvas dimensions to match video
        canvasEl.width = webcamEl.width;
        canvasEl.height = webcamEl.height;
        
        // Clear the canvas with transparent background
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        
        // Detect poses
        const poses = await detector.estimatePoses(webcamEl);
        
        // Mirror the pose data directly
        if (poses && poses.length > 0) {
          poses.forEach(pose => {
            if (pose.keypoints) {
              pose.keypoints.forEach(keypoint => {
                // Mirror the x coordinates relative to canvas width
                keypoint.x = canvasEl.width - keypoint.x;
              });
            }
          });
        }
        
        // Now draw with normal context (no mirroring needed since data is mirrored)
        drawResults(ctx, poses, canvasEl.width, canvasEl.height);
        
        // Update UI
        updateUI();
        
        // Continue the loop
        requestAnimationFrame(detectAndRender);
      } catch (error) {
        console.error("Error in pose detection:", error);
        statusEl.textContent = "Error: " + error.message;
        stopDetection();
      }
    }
    
    // Start tracking
    async function startTracking() {
      try {
        // Hide the start button and show loading
        startButtonEl.style.display = 'none';
        loadingEl.style.display = 'flex';
        statusMessageEl.textContent = 'Setting up webcam...';
        
        // Setup webcam
        await setupWebcam();
        
        // Load pose model
        statusMessageEl.textContent = 'Loading pose detection model...';
        detector = await loadPoseDetectionModel();
        
        // Hide loading screen, show webcam (don't hide it anymore)
        loadingEl.style.display = 'none';
        webcamEl.style.display = 'block'; // Make sure webcam is visible
        
        // Start the detection loop
        isRunning = true;
        detectAndRender();
      } catch (error) {
        console.error('Error starting tracking:', error);
        statusMessageEl.textContent = 'Error starting tracking: ' + error.message;
        startButtonEl.style.display = 'block';
      }
    }
    
    // Initialize the app
    async function init() {
      try {
        // Check if TensorFlow.js is available
        if (typeof tf === 'undefined') {
          statusMessageEl.textContent = 'TensorFlow.js not loaded. Check your internet connection.';
          return;
        }
        
        // Show start button
        statusMessageEl.textContent = 'Ready to start. Click the button below.';
        startButtonEl.style.display = 'block';
        startButtonEl.addEventListener('click', startTracking);
        
        // Initialize rep counter variables
        repCount = 0;
        isReadyForNextRep = true; // Start ready for first rep
        hasReachedOmega = false;
        
        // Update rep counter display
        updateRepCounter();
      } catch (error) {
        console.error('Initialization error:', error);
        statusMessageEl.textContent = 'Initialization error: ' + error.message;
      }
    }
    
    // Start when page is loaded
    window.onload = init;

    // Helper function to check if an angle is within a certain range of a target
    function isAngleCloseToTarget(angle, target, tolerance) {
      return Math.abs(angle - target) <= tolerance;
    }

    // Function to update the rep counter display
    function updateRepCounter() {
      document.getElementById('rep-counter').textContent = repCount;
    }
  </script>
</body>
</html>