<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpha-Omega Left Elbow Angle Tracker</title>
  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
  <!-- Load MoveNet model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
      box-sizing: border-box;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    
    .video-container {
      position: relative;
      width: 640px;
      height: 480px;
      background-color: #000;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 20px;
    }
    
    .controls-section {
      flex: 1;
      min-width: 280px;
      max-width: 350px;
      overflow-y: auto;
      max-height: 480px;
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 12px;
    }
    
    .controls-section h2 {
      font-size: 18px;
      margin: 0 0 12px 0;
      padding-bottom: 8px;
    }
    
    .controls-section h3 {
      font-size: 16px;
      margin: 0 0 8px 0;
    }
    
    .metrics {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    
    .metric {
      text-align: left;
    }
    
    .metric-label {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: bold;
    }
    
    .metric-value.in-range {
      color: #4ade80;
    }
    
    .metric-value.out-range {
      color: #fbbf24;
    }
    
    .progress-bar {
      width: 100%;
      height: 24px;
      background-color: #3a3a3a;
      border-radius: 9999px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(to right, #3b82f6, #4ade80);
      transition: width 0.3s ease-in-out;
    }
    
    .note {
      font-size: 12px;
      color: #aaa;
    }
    
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }
    
    .loading-icon {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid #fff;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #status-message {
      margin-top: 10px;
      text-align: center;
    }

    button {
      background-color: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    button:hover {
      background-color: #2563eb;
    }
    
    .joint-toggles {
      background-color: #2a2a2a;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 12px;
    }
    
    .toggle-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }
    
    .toggle-label {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      font-size: 13px;
      background-color: #333;
      border-radius: 6px;
      margin-bottom: 4px;
    }
    
    .joint-setting {
      padding: 3px 6px;
      margin-top: 1px;
      margin-bottom: 6px;
      background-color: #333;
      border-radius: 4px;
    }
    
    input[data-joint]:checked ~ .joint-setting {
      display: block;
    }
    
    .angle-control {
      margin-bottom: 4px;
    }
    
    .angle-control label {
      font-size: 12px;
      display: block;
      margin-bottom: 2px;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
    }
    
    .slider-container input[type="range"] {
      width: 100%;
      margin: 0;
    }
    
    .global-controls {
      margin: 16px auto 0;
      width: 100%;
      max-width: 600px;
    }
    
    .rep-counter-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3;
      pointer-events: none;
    }

    .current-angle {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 32px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 8px;
      font-weight: bold;
    }

    .rep-count {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 96px;
      color: white;
      background-color: rgba(59, 130, 246, 0.7);
      padding: 10px 20px;
      border-radius: 12px;
      font-weight: bold;
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
    }
    
    .tab-button {
      background-color: #333;
      color: #aaa;
      border: none;
      padding: 8px 12px;
      margin-right: 2px;
      cursor: pointer;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .tab-button:hover {
      background-color: #444;
      color: white;
    }
    
    .tab-button.active {
      background-color: #2a2a2a;
      color: white;
      border-bottom: 2px solid #3b82f6;
    }
    
    .tab-content {
      background-color: #2a2a2a;
      border-radius: 0 0 8px 8px;
      padding: 16px;
    }
    
    .tab-pane {
      display: none;
    }
    
    .tab-pane.active {
      display: block;
    }
    
    .compact-presets {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
    
    .compact-presets .preset-button {
      font-size: 12px;
      padding: 5px 8px;
    }
    
    .joint-angle-displays {
      display: none;
    }
    
    .joint-angle {
      font-size: 24px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
    }

    .joint-toggles {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .toggle-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }
    
    .toggle-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      background-color: #333;
      border-radius: 6px;
      transition: background-color 0.2s;
    }
    
    .toggle-label:hover {
      background-color: #444;
    }
    
    .toggle-label input[type="checkbox"] {
      margin-right: 8px;
      width: 16px;
      height: 16px;
    }
    
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: auto;
    }
    
    .joint-name {
      font-size: 14px;
    }
    
    .joint-settings {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 16px;
    }
    
    .angle-controls {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .angle-control {
      margin-bottom: 8px;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .slider-container input[type="range"] {
      flex: 1;
    }
    
    .slider-container input[type="number"] {
      width: 60px;
    }
    
    .compact-presets {
      display: flex;
      gap: 6px;
    }
    
    .preset-button {
      font-size: 12px;
      padding: 4px 8px;
    }

    #webcam {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transform: scaleX(-1);
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .dual-slider {
      position: relative;
      height: 16px;
      padding: 2px 0;
      margin-bottom: 2px;
    }
    
    .slider-track {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 2px;
      background: #444;
      border-radius: 1px;
    }
    
    .slider-range {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      height: 2px;
      background: #3b82f6;
      border-radius: 1px;
    }
    
    .slider-handle {
      position: absolute;
      top: 50%;
      width: 10px;
      height: 10px;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0,0,0,0.2);
    }
    
    .slider-handle:hover {
      background: #f0f0f0;
    }
    
    .slider-handle.alpha {
      background: #4ade80;
    }
    
    .slider-handle.omega {
      background: #fb923c;
    }
    
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-bottom: 1px;
      font-size: 10px;
    }

    .joint-controls {
      width: 100%;
      max-width: 640px;
      margin-top: 20px;
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 16px;
    }
    
    h3 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 15px;
    }

    /* Style the state indicator */
    .state-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
    }
    
    /* Different colors for different states */
    .state-waiting {
      color: #f59e0b; /* Amber */
    }
    
    .state-ready {
      color: #10b981; /* Green */
    }
    
    .state-completed {
      color: #3b82f6; /* Blue */
    }

    .exercise-selection {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #2a2a2a;
      border-radius: 8px;
    }

    .exercise-selector {
      width: 100%;
      padding: 8px;
      background-color: #3a3a3a;
      color: white;
      border: 1px solid #444;
      border-radius: 4px;
      font-size: 16px;
      margin-top: 8px;
    }

    .exercise-selector:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .stage-info {
      margin-top: 8px;
      font-size: 14px;
      color: #aaa;
    }

    .global-settings {
      width: 100%;
      max-width: 640px;
      margin: 20px auto;
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 16px;
    }

    .setting-control {
      margin: 12px 0;
    }

    .setting-control label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #e0e0e0;
    }

    .setting-description {
      font-size: 12px;
      color: #aaa;
      margin-top: 4px;
      line-height: 1.4;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-container input[type="range"] {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: #3a3a3a;
      border-radius: 3px;
      outline: none;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb:hover {
      background: #2563eb;
    }

    /* Add styles for debug panel */
    .debug-panel {
      width: 100%;
      max-width: 640px;
      margin: 20px auto;
      background-color: #2a2a2a;
      border-radius: 8px;
      padding: 16px;
      font-family: monospace;
    }

    .debug-content {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 16px;
    }

    .debug-section {
      background-color: #1a1a1a;
      padding: 12px;
      border-radius: 4px;
    }

    .debug-section h4 {
      margin: 0 0 8px 0;
      color: #3b82f6;
      font-size: 14px;
    }

    .debug-section pre {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      color: #e0e0e0;
      font-size: 12px;
      line-height: 1.4;
    }

    .condition-met {
      color: #4ade80;
    }

    .condition-not-met {
      color: #fb923c;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="video-container">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
      
      <div class="rep-counter-overlay">
        <div class="rep-count">
          <span id="rep-counter">0</span>
        </div>
        <div class="state-indicator">
          <span id="state-status">Waiting for Begin</span>
        </div>
      </div>
      
      <div id="loading" class="loading">
        <div class="loading-icon"></div>
        <p id="status-message">Loading TensorFlow.js...</p>
        <button id="start-button" style="display: none;">Start Tracking</button>
      </div>
    </div>
    
    <!-- Global Settings - Always Visible -->
    <div class="global-settings">
      <h3>Detection Settings</h3>
      <div class="setting-control">
        <label for="angle-tolerance">Detection Tolerance: <span id="angle-tolerance-value">25</span>°</label>
        <div class="slider-container">
          <input type="range" id="angle-tolerance" min="1" max="45" value="25" step="1">
        </div>
        <div class="setting-description">
          Adjust how precisely angles need to match their targets. Higher values are more forgiving.
        </div>
      </div>
      
      <div class="setting-control">
        <label for="rolling-average-duration">Rolling Average Duration: <span id="rolling-average-duration-value">5</span>s</label>
        <div class="slider-container">
          <input type="range" id="rolling-average-duration" min="1" max="10" value="5" step="0.5">
        </div>
        <div class="setting-description">
          Adjust how long the rolling average window is. Longer duration means smoother movement but more lag.
        </div>
      </div>
    </div>

    <!-- Debug Information Display -->
    <div class="debug-panel">
      <h3>Debug Information</h3>
      <div class="debug-content">
        <div class="debug-section">
          <h4>Current State</h4>
          <pre id="debug-current-state"></pre>
        </div>
        <div class="debug-section">
          <h4>Transition Conditions</h4>
          <pre id="debug-conditions"></pre>
        </div>
        <div class="debug-section">
          <h4>Joint Angles</h4>
          <pre id="debug-angles"></pre>
        </div>
      </div>
    </div>

    <div class="joint-controls">
      <div class="exercise-selection">
        <h3>Select Exercise</h3>
        <select id="exercise-selector" class="exercise-selector">
          <option value="">Custom Exercise</option>
        </select>
        <div id="stage-info" class="stage-info"></div>
      </div>

      <div class="joint-toggles">
        <h3>Select Joints to Track</h3>
        <div class="toggle-grid">
          <!-- Left Shoulder -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-shoulder">
              <span class="joint-name">Left Shoulder</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="left-shoulder-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-shoulder-alpha-value">90</span>°</span>
                  <span>End: <span id="left-shoulder-omega-value">180</span>°</span>
                </div>
                <div class="dual-slider" id="left-shoulder-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="90"></div>
                  <div class="slider-handle omega" data-value="180"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Shoulder -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-shoulder">
              <span class="joint-name">Right Shoulder</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="right-shoulder-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-shoulder-alpha-value">90</span>°</span>
                  <span>End: <span id="right-shoulder-omega-value">180</span>°</span>
                </div>
                <div class="dual-slider" id="right-shoulder-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="90"></div>
                  <div class="slider-handle omega" data-value="180"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Left Elbow -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-elbow" checked>
              <span class="joint-name">Left Elbow</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="left-elbow-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-elbow-alpha-value">160</span>°</span>
                  <span>End: <span id="left-elbow-omega-value">45</span>°</span>
                </div>
                <div class="dual-slider" id="left-elbow-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="160"></div>
                  <div class="slider-handle omega" data-value="45"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Elbow -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-elbow">
              <span class="joint-name">Right Elbow</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="right-elbow-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-elbow-alpha-value">160</span>°</span>
                  <span>End: <span id="right-elbow-omega-value">45</span>°</span>
                </div>
                <div class="dual-slider" id="right-elbow-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="160"></div>
                  <div class="slider-handle omega" data-value="45"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Left Hip -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-hip">
              <span class="joint-name">Left Hip</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="left-hip-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-hip-alpha-value">180</span>°</span>
                  <span>End: <span id="left-hip-omega-value">90</span>°</span>
                </div>
                <div class="dual-slider" id="left-hip-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="180"></div>
                  <div class="slider-handle omega" data-value="90"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Hip -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-hip">
              <span class="joint-name">Right Hip</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="right-hip-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-hip-alpha-value">180</span>°</span>
                  <span>End: <span id="right-hip-omega-value">90</span>°</span>
                </div>
                <div class="dual-slider" id="right-hip-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="180"></div>
                  <div class="slider-handle omega" data-value="90"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Left Knee -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="left-knee">
              <span class="joint-name">Left Knee</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="left-knee-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="left-knee-alpha-value">170</span>°</span>
                  <span>End: <span id="left-knee-omega-value">90</span>°</span>
                </div>
                <div class="dual-slider" id="left-knee-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="170"></div>
                  <div class="slider-handle omega" data-value="90"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Knee -->
          <div>
            <label class="toggle-label">
              <input type="checkbox" data-joint="right-knee">
              <span class="joint-name">Right Knee</span>
              <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
            </label>
            
            <div class="joint-setting" id="right-knee-settings">
              <div class="angle-controls">
                <div class="slider-labels">
                  <span>Begin: <span id="right-knee-alpha-value">170</span>°</span>
                  <span>End: <span id="right-knee-omega-value">90</span>°</span>
                </div>
                <div class="dual-slider" id="right-knee-slider">
                  <div class="slider-track"></div>
                  <div class="slider-range"></div>
                  <div class="slider-handle alpha" data-value="170"></div>
                  <div class="slider-handle omega" data-value="90"></div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // Add joint lock state to each joint config
    const jointConfig = {
      'left-hip': {
        alpha: 180,
        omega: 90,
        keypoints: {
          start: 5,    // left shoulder
          middle: 11,  // left hip
          end: 13     // left knee
        },
        color: 'rgb(59, 130, 246)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false,
        lockState: {
          isLocked: false,
          startTime: 0,
          targetAngle: null
        },
        angleHistory: [],
        lastUpdateTime: 0
      },
      'right-hip': {
        alpha: 180,
        omega: 90,
        keypoints: {
          start: 6,    // right shoulder
          middle: 12,  // right hip
          end: 14     // right knee
        },
        color: 'rgb(59, 130, 246)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false,
        lockState: {
          isLocked: false,
          startTime: 0,
          targetAngle: null
        },
        angleHistory: [],
        lastUpdateTime: 0
      },
      'left-knee': {
        alpha: 170,
        omega: 90,
        keypoints: {
          start: 11,
          middle: 13,
          end: 15
        },
        color: 'rgb(59, 130, 246)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false,
        lockState: {
          isLocked: false,
          startTime: 0,
          targetAngle: null
        },
        angleHistory: [],
        lastUpdateTime: 0
      },
      'right-knee': {
        alpha: 170,
        omega: 90,
        keypoints: {
          start: 12,
          middle: 14,
          end: 16
        },
        color: 'rgb(59, 130, 246)',
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: false,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false,
        lockState: {
          isLocked: false,
          startTime: 0,
          targetAngle: null
        },
        angleHistory: [],
        lastUpdateTime: 0
      }
    };

    // Add lock-in mechanism functions
    function checkJointLock(joint, config, currentAngle) {
      const now = performance.now();
      const lockTimeout = 5000; // 5 second lock timeout
      const maxDeviation = 5;  // 5 degrees max deviation
      
      // Check if we're at a target position
      const atAlpha = Math.abs(currentAngle - config.alpha) <= angleTolerance;
      const atOmega = Math.abs(currentAngle - config.omega) <= angleTolerance;
      
      if (!config.lockState.isLocked) {
        // Start lock if at either target position
        if (atAlpha || atOmega) {
          config.lockState.isLocked = true;
          config.lockState.startTime = now;
          config.lockState.targetAngle = atAlpha ? config.alpha : config.omega;
        }
      } else {
        // Check if we're still within tolerance
        const deviation = Math.abs(currentAngle - config.lockState.targetAngle);
        if (deviation > maxDeviation) {
          // Reset lock if deviated too far
          config.lockState.isLocked = false;
          config.lockState.startTime = 0;
          config.lockState.targetAngle = null;
          return false;
        }
        
        // Check if we've maintained position long enough
        if (now - config.lockState.startTime >= lockTimeout) {
          return true;
        }
      }
      
      return false;
    }

    // Check if all active joints are ready for state transition
    function checkJointsForTransition() {
      let allJointsReady = true;
      
      for (const joint in jointConfig) {
        const config = jointConfig[joint];
        if (!config.active) continue;
        
        const angle = config.smoothedAngle;
        const atTarget = Math.abs(angle - config.omega) <= angleTolerance;
        
        // Joint must either be locked or at target position
        if (!config.lockState.isLocked && !atTarget) {
          allJointsReady = false;
          break;
        }
      }
      
      return allJointsReady;
    }

    // Exercise handling
    let exercises = {};
    let currentExercise = null;
    let currentStage = 0;

    // Load exercises from JSON file
    async function loadExercises() {
      try {
        const response = await fetch('exercises.json');
        exercises = await response.json();
        populateExerciseSelector();
      } catch (error) {
        console.error('Error loading exercises:', error);
      }
    }

    // Populate exercise selector dropdown
    function populateExerciseSelector() {
      const selector = document.getElementById('exercise-selector');
      Object.keys(exercises).forEach(exerciseName => {
        const option = document.createElement('option');
        option.value = exerciseName;
        option.textContent = exerciseName.split('_').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        selector.appendChild(option);
      });
    }

    // Add debug update function
    function updateDebugDisplay() {
      const debugCurrentState = document.getElementById('debug-current-state');
      const debugConditions = document.getElementById('debug-conditions');
      const debugAngles = document.getElementById('debug-angles');

      if (!currentExercise) {
        debugCurrentState.textContent = "No exercise selected";
        debugConditions.textContent = "N/A";
        debugAngles.textContent = "N/A";
        return;
      }

      const stageInfo = currentExercise[currentStage];
      if (!stageInfo) {
        debugCurrentState.textContent = "Invalid stage";
        debugConditions.textContent = "N/A";
        debugAngles.textContent = "N/A";
        return;
      }
      
      // Update current state info
      const stateInfo = {
        'Exercise': document.getElementById('exercise-selector').value,
        'Current Stage': currentStage,
        'Stage Name': stageInfo.name,
        'Stage Type': stageInfo.type,
        'Current State': exerciseState.currentState,
        'Tolerance': angleTolerance + '°'
      };
      debugCurrentState.textContent = JSON.stringify(stateInfo, null, 2);

      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        debugConditions.textContent = "No movements defined for stage";
        debugAngles.textContent = "N/A";
        return;
      }

      // Check and display all conditions
      const conditions = [];
      const anglesList = [];
      
      for (const [joint, targetAngles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        if (!jointConfig[normalizedJoint]?.active) continue;

        const currentAngle = jointConfig[normalizedJoint].smoothedAngle || 0;
        const startAngle = targetAngles.start;
        const endAngle = targetAngles.end;
        const diffFromStart = Math.abs(currentAngle - startAngle);
        const diffFromEnd = Math.abs(currentAngle - endAngle);

        // Add angle information
        anglesList.push({
          joint: normalizedJoint,
          current: Math.round(currentAngle) + '°',
          target: {
            start: startAngle + '°',
            end: endAngle + '°'
          },
          differences: {
            fromStart: Math.round(diffFromStart) + '°',
            fromEnd: Math.round(diffFromEnd) + '°'
          }
        });

        // Add condition information based on current state and stage type
        if (stageInfo.type === 'hold') {
          conditions.push({
            description: `${normalizedJoint} at hold angle (${startAngle}° ±${angleTolerance}°)`,
            met: diffFromStart <= angleTolerance,
            current: Math.round(currentAngle) + '°',
            diff: Math.round(diffFromStart) + '°'
          });
        } else {
          // For movement stages, show condition based on current state
          if (exerciseState.currentState === ExerciseState.WAITING_FOR_START) {
            conditions.push({
              description: `${normalizedJoint} at start position (${startAngle}° ±${angleTolerance}°)`,
              met: diffFromStart <= angleTolerance,
              current: Math.round(currentAngle) + '°',
              diff: Math.round(diffFromStart) + '°'
            });
          } else {
            conditions.push({
              description: `${normalizedJoint} at end position (${endAngle}° ±${angleTolerance}°)`,
              met: diffFromEnd <= angleTolerance,
              current: Math.round(currentAngle) + '°',
              diff: Math.round(diffFromEnd) + '°'
            });
          }
        }
      }

      // Format conditions with colored status
      const formattedConditions = conditions.map(c => 
        `${c.met ? '✓' : '✗'} ${c.description}\n` +
        `  Current: ${c.current}, Diff: ${c.diff}` +
        `  ${c.met ? '(MET)' : '(NOT MET)'}`
      ).join('\n\n');

      debugConditions.textContent = formattedConditions || "Waiting for pose detection...";
      debugAngles.textContent = JSON.stringify(anglesList, null, 2);
    }

    // Handle exercise stage updates
    function handleExerciseStage(exercise, stage) {
      const stageInfo = exercise[stage];
      if (!stageInfo) {
        console.error('Invalid stage:', stage);
        return;
      }

      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        console.error('No movements defined for stage:', stageInfo.name);
        return;
      }
      
      console.log('Exercise Stage:', stageInfo.name);
      console.log('Movements to configure:', movements);
      
      // Reset state machine
      exerciseState.currentState = ExerciseState.WAITING_FOR_START;
      exerciseState.lastStateChangeTime = Date.now();
      
      // Update stage info display
      document.getElementById('stage-info').textContent = `Stage: ${stageInfo.name}`;
      
      // Update joint configurations
      for (const [joint, angles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        console.log('Configuring joint:', normalizedJoint, 'with angles:', angles);
        
        if (jointConfig[normalizedJoint]) {
          // Enable the joint
          const toggle = document.querySelector(`input[data-joint="${normalizedJoint}"]`);
          console.log('Found toggle element:', toggle ? 'yes' : 'no');
          
          if (toggle) {
            toggle.checked = true;
            jointConfig[normalizedJoint].active = true;
            console.log('Activated joint:', normalizedJoint);
          } else {
            console.warn('Toggle element not found for joint:', normalizedJoint);
          }
          
          // Update angles
          jointConfig[normalizedJoint].alpha = angles.start;
          jointConfig[normalizedJoint].omega = angles.end;
          
          // Update UI
          updateJointUI(normalizedJoint, angles);
        } else {
          console.warn('Joint not found in config:', normalizedJoint);
        }
      }
      
      // Update debug display
      updateDebugDisplay();
    }

    // Handle exercise selection
    function handleExerciseSelection(exerciseName) {
      console.log('Selected exercise:', exerciseName);
      
      const jointTogglesSection = document.querySelector('.joint-toggles');
      
      // Reset rep counter and states
      globalRepCount = 0;
      updateRepCounter();
      repState = {
        allJointsReady: false,
        allJointsCompleted: false,
        lastRepTime: 0
      };
      
      if (!exerciseName) {
        console.log('Custom exercise mode selected');
        // Custom Exercise selected
        currentExercise = null;
        currentStage = 0;
        document.getElementById('stage-info').textContent = '';
        
        // Show joint toggles
        jointTogglesSection.style.display = 'block';
        
        // Reset all joints to default state
        Object.keys(jointConfig).forEach(joint => {
          const toggle = document.querySelector(`input[data-joint="${joint}"]`);
          if (toggle) {
            toggle.disabled = false;  // Enable toggle controls
          }
        });

        // Update debug display for custom mode
        updateDebugDisplay();
        return;
      }
      
      const exercise = exercises[exerciseName];
      if (!exercise) {
        console.warn('Exercise not found:', exerciseName);
        return;
      }
      
      console.log('Loading exercise:', exerciseName, exercise);
      currentExercise = exercise;
      currentStage = 0;
      
      // Hide joint toggles for predefined exercises
      jointTogglesSection.style.display = 'none';
      
      // Reset all joints first
      Object.keys(jointConfig).forEach(joint => {
        const toggle = document.querySelector(`input[data-joint="${joint}"]`);
        if (toggle) {
          toggle.checked = false;
          jointConfig[joint].active = false;
          toggle.disabled = true;  // Disable toggle controls
        }
      });
      
      console.log('All joints reset, configuring initial stage');
      // Configure initial stage
      handleExerciseStage(exercise, currentStage);
    }

    // Add exercise selector event listener
    document.getElementById('exercise-selector').addEventListener('change', function(e) {
      handleExerciseSelection(e.target.value);
    });

    // DOM Elements
    const webcamEl = document.getElementById('webcam');
    const canvasEl = document.getElementById('canvas');
    const loadingEl = document.getElementById('loading');
    const startButtonEl = document.getElementById('start-button');
    const statusMessageEl = document.getElementById('status-message');
    const repCounterEl = document.getElementById('rep-counter');
    const jointToggles = document.querySelectorAll('input[type="checkbox"][data-joint]');
    const jointAngleDisplaysEl = document.querySelector('.joint-angle-displays');
    
    // Add variable for tolerance
    let angleTolerance = 25;
    
    // Add the tolerance control elements
    const angleToleranceSlider = document.getElementById('angle-tolerance');
    const angleToleranceValue = document.getElementById('angle-tolerance-value');
    
    // Setup tolerance control event listeners
    angleToleranceSlider.addEventListener('input', function() {
      const value = parseInt(this.value);
      angleTolerance = value;
      angleToleranceValue.textContent = value;
    });
    
    // Tracking state
    let detector;
    let smoothingFactor = 0.85;
    let positionSmoothingFactor = 0.7;
    let isRunning = false;
    let activeJoint = 'left-elbow';
    let lastValidPoseTime = 0;
    const messageDelayThreshold = 2000;
    
    // Setup joint toggle event listeners
    jointToggles.forEach(toggle => {
      const jointId = toggle.getAttribute('data-joint');
      const settingsEl = document.getElementById(`${jointId}-settings`);
      
      // Set initial state
      if (settingsEl) {
        settingsEl.style.display = toggle.checked ? 'block' : 'none';
      }
      
      // Add change event listener
      toggle.addEventListener('change', () => {
        if (settingsEl) {
          settingsEl.style.display = toggle.checked ? 'block' : 'none';
        }
        
        if (jointConfig[jointId]) {
          jointConfig[jointId].active = toggle.checked;
          updateAngleDisplays();
        }
      });
    });
    
    // Setup all range inputs using delegation and data attributes for DRY code
    document.addEventListener('input', function(e) {
      if (e.target.matches('input[type="range"][data-joint][data-param]')) {
        const joint = e.target.getAttribute('data-joint');
        const param = e.target.getAttribute('data-param');
        const value = parseInt(e.target.value);
        
        // Update the config
        jointConfig[joint][param] = value;
        
        // Update the display and number input
        document.getElementById(`${joint}-${param}-value`).textContent = value;
        document.getElementById(`${joint}-${param}-input`).value = value;
      }
    });
    
    // Setup all number inputs
    document.addEventListener('change', function(e) {
      if (e.target.matches('input[type="number"][data-joint][data-param]')) {
        const joint = e.target.getAttribute('data-joint');
        const param = e.target.getAttribute('data-param');
        let value = parseInt(e.target.value);
        
        // Validate input
        if (isNaN(value) || value < 0) {
          value = 0;
        } else if (value > 180) {
          value = 180;
        }
        
        // Update the value
        e.target.value = value;
        jointConfig[joint][param] = value;
        
        // Update the display and range input
        document.getElementById(`${joint}-${param}-value`).textContent = value;
        document.getElementById(`${joint}-${param}`).value = value;
      }
    });
    
    // Setup preset buttons
    document.addEventListener('click', function(e) {
      if (e.target.matches('.preset-button[data-joint]')) {
        const joint = e.target.getAttribute('data-joint');
        const alpha = parseInt(e.target.getAttribute('data-alpha'));
        const omega = parseInt(e.target.getAttribute('data-omega'));
        
        // Update the config
        jointConfig[joint].alpha = alpha;
        jointConfig[joint].omega = omega;
        
        // Update all UI elements
        document.getElementById(`${joint}-alpha-value`).textContent = alpha;
        document.getElementById(`${joint}-omega-value`).textContent = omega;
        document.getElementById(`${joint}-alpha`).value = alpha;
        document.getElementById(`${joint}-omega`).value = omega;
        document.getElementById(`${joint}-alpha-input`).value = alpha;
        document.getElementById(`${joint}-omega-input`).value = omega;
      }
    });
    
    // Canvas setup
    const ctx = canvasEl.getContext('2d');
    
    // Initialize the webcam
    async function setupWebcam() {
      return new Promise((resolve, reject) => {
        navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        })
        .then(stream => {
          webcamEl.srcObject = stream;
          webcamEl.onloadedmetadata = () => {
            webcamEl.width = webcamEl.videoWidth;
            webcamEl.height = webcamEl.videoHeight;
            resolve(webcamEl);
          };
        })
        .catch(error => {
          statusMessageEl.textContent = 'Error accessing webcam: ' + error.message;
          reject(error);
        });
      });
    }
    
    // Load the pose detection model - using MoveNet which is more reliable in browsers
    async function loadPoseDetectionModel() {
      try {
        // Use MoveNet SinglePose - more reliable than BlazePose in browser environments
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true
        };
        
        return await poseDetection.createDetector(model, detectorConfig);
      } catch (error) {
        console.error('Error loading model:', error);
        statusMessageEl.textContent = 'Error loading model: ' + error.message;
        throw error;
      }
    }
    
    // Calculate angle between three points
    function calculateAngle(a, b, c) {
      // Vector BA
      const ba = { x: a.x - b.x, y: a.y - b.y };
      // Vector BC
      const bc = { x: c.x - b.x, y: c.y - b.y };
      
      // Dot product and magnitudes
      const dotProduct = ba.x * bc.x + ba.y * bc.y;
      const baMagnitude = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
      const bcMagnitude = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
      
      // Cosine of angle
      const cosAngle = dotProduct / (baMagnitude * bcMagnitude);
      
      // Convert to degrees
      let angleDegrees = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
      
      return angleDegrees;
    }
    
    // Find angle in radians on the unit circle
    function getAngleRadians(x, y) {
      return Math.atan2(y, x);
    }
    
    // Check if current angle is between alpha and omega, considering direction
    function isAngleInRange(currentAngle, alpha, omega) {
      // If alpha <= omega, we're moving in the increasing direction
      if (alpha <= omega) {
        return currentAngle >= alpha && currentAngle <= omega;
      } 
      // If alpha > omega, we're moving in the decreasing direction
      else {
        return currentAngle <= alpha && currentAngle >= omega;
      }
    }
    
    // Smooth angle using exponential moving average
    function smoothAngle(currentAngle, previousSmoothedAngle, smoothingFactor) {
      return smoothingFactor * previousSmoothedAngle + (1 - smoothingFactor) * currentAngle;
    }
    
    // Helper function to check if an angle is within a certain range of a target
    function isAngleCloseToTarget(angle, target, tolerance) {
      return Math.abs(angle - target) <= tolerance;
    }
    
    // Function to update the rep counter display
    function updateRepCounter() {
      // Sum up reps from all active joints
      let totalReps = 0;
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          totalReps += jointConfig[joint].repCount;
        }
      }
      repCounterEl.textContent = totalReps;
    }
    
    // Create angle display elements for each joint
    function createAngleDisplays() {
      // Function emptied to prevent creating angle displays
      return;
    }
    
    // Update angle displays
    function updateAngleDisplays() {
      // Keep only the part that updates active status in jointConfig
      for (const joint in jointConfig) {
        const toggle = document.querySelector(`input[data-joint="${joint}"]`);
        if (toggle) {
          jointConfig[joint].active = toggle.checked;
        }
      }
      // Don't update any displays
    }
    
    // Draw angle visualization for a specific joint
    function drawAngleVisualization(ctx, joint, keypoints) {
      const config = jointConfig[joint];
      const startPoint = keypoints[config.keypoints.start];
      const middlePoint = keypoints[config.keypoints.middle];
      const endPoint = keypoints[config.keypoints.end];
      
      // Make sure all keypoints are present with good confidence
      if (startPoint && middlePoint && endPoint && 
          startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
        
        // Calculate vectors
        const vectorA = { 
          x: startPoint.x - middlePoint.x, 
          y: startPoint.y - middlePoint.y 
        };
        const vectorB = { 
          x: endPoint.x - middlePoint.x, 
          y: endPoint.y - middlePoint.y 
        };
        
        // Get the angle in radians
        const angleA = getAngleRadians(vectorA.x, vectorA.y);
        const angleB = getAngleRadians(vectorB.x, vectorB.y);
        
        // Radius for drawing arcs
        const radius = 30;
        
        // Calculate cross product to determine the direction
        const crossProduct = vectorA.x * vectorB.y - vectorA.y * vectorB.x;

        // Calculate the actual angle between vectors (0 to 180 degrees)
        const angleBetweenVectors = Math.acos(
          (vectorA.x * vectorB.x + vectorA.y * vectorB.y) / 
          (Math.sqrt(vectorA.x * vectorA.x + vectorA.y * vectorA.y) * 
           Math.sqrt(vectorB.x * vectorB.x + vectorB.y * vectorB.y))
        );

        // Calculate color based on proximity to target
        const currentAngle = config.smoothedAngle;
        const targetAngle = config.omega;
        const diffFromTarget = Math.abs(currentAngle - targetAngle);
        
        // Color transition from blue to green
        let jointColor;
        if (diffFromTarget <= angleTolerance) {
          // Green when within tolerance
          jointColor = 'rgba(34, 197, 94, 1)';
        } else {
          // Calculate a gradient from blue to green based on proximity
          const maxDiff = angleTolerance * 3; // Start transition at 3x tolerance
          const progress = Math.max(0, Math.min(1, 1 - (diffFromTarget / maxDiff)));
          
          // RGB values for blue and green
          const blue = { r: 59, g: 130, b: 246 };
          const green = { r: 34, g: 197, b: 94 };
          
          // Interpolate between blue and green
          const r = Math.round(blue.r + (green.r - blue.r) * progress);
          const g = Math.round(blue.g + (green.g - blue.g) * progress);
          const b = Math.round(blue.b + (green.b - blue.b) * progress);
          
          jointColor = `rgba(${r}, ${g}, ${b}, 1)`;
        }

        // Draw skeleton lines with the calculated color
        ctx.strokeStyle = jointColor;
        ctx.lineWidth = 6;
        
        // First segment
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(middlePoint.x, middlePoint.y);
        ctx.stroke();
        
        // Second segment
        ctx.beginPath();
        ctx.moveTo(middlePoint.x, middlePoint.y);
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.stroke();
        
        // Draw joint keypoints with the same color
        ctx.fillStyle = jointColor;
        
        // Start point
        ctx.beginPath();
        ctx.arc(startPoint.x, startPoint.y, 8, 0, 2 * Math.PI);
        ctx.fill();
        
        // Middle point (slightly larger)
        ctx.beginPath();
        ctx.arc(middlePoint.x, middlePoint.y, 10, 0, 2 * Math.PI);
        ctx.fill();
        
        // End point
        ctx.beginPath();
        ctx.arc(endPoint.x, endPoint.y, 8, 0, 2 * Math.PI);
        ctx.fill();
        
        return true;
      }
      
      return false;
    }
    
    // Add rolling average functions
    function updateRollingAverage(joint, config, currentAngle) {
      const now = performance.now();
      
      // Add new measurement with timestamp
      config.angleHistory.push({
        angle: currentAngle,
        timestamp: now
      });
      
      // Remove measurements older than window
      config.angleHistory = config.angleHistory.filter(
        entry => (now - entry.timestamp) <= rollingAverageDuration
      );
      
      // Calculate weighted average
      if (config.angleHistory.length > 0) {
        let totalWeight = 0;
        let weightedSum = 0;
        
        config.angleHistory.forEach(entry => {
          // More recent entries get higher weight
          const age = now - entry.timestamp;
          const weight = 1 - (age / rollingAverageDuration);
          
          weightedSum += entry.angle * weight;
          totalWeight += weight;
        });
        
        config.smoothedAngle = weightedSum / totalWeight;
      } else {
        config.smoothedAngle = currentAngle;
      }
    }
    
    // Update the drawResults function to use rolling average
    function drawResults(ctx, poses, canvasWidth, canvasHeight) {
      // Clear the canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      if (!poses || poses.length === 0) {
        return;
      }
      
      // Get the first detected pose
      const pose = poses[0];
      const keypoints = pose.keypoints;
      
      // Process each joint configured for tracking
      let successfulVisualizations = 0;
      
      for (const joint in jointConfig) {
        // Only process and visualize active joints
        if (jointConfig[joint].active) {
          const config = jointConfig[joint];
          const startPoint = keypoints[config.keypoints.start];
          const middlePoint = keypoints[config.keypoints.middle];
          const endPoint = keypoints[config.keypoints.end];
          
          // Check if we have all keypoints with good confidence
          if (startPoint && middlePoint && endPoint && 
              startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
            
            // Calculate the raw angle
            const angle = calculateAngle(startPoint, middlePoint, endPoint);
            
            // Store the raw angle
            config.currentAngle = angle;
            
            // Update rolling average
            updateRollingAverage(joint, config, angle);
            
            // Draw the visualization
            if (drawAngleVisualization(ctx, joint, keypoints)) {
              successfulVisualizations++;
            }
          }
        }
      }
    }
    
    // Update UI elements
    function updateUI() {
      // Update angle displays for all active joints
      updateAngleDisplays();
      
      // REP COUNTING LOGIC - Process each active joint
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          const config = jointConfig[joint];
          const angle = config.smoothedAngle;
          
          // Check joint lock
          checkJointLock(joint, config, angle);
        }
      }
      
      // Check if all joints are ready for transition
      if (checkJointsForTransition()) {
        // Process each joint for rep counting
        for (const joint in jointConfig) {
          if (jointConfig[joint].active) {
            const config = jointConfig[joint];
            const angle = config.smoothedAngle;
            const isAtOmega = isAngleCloseToTarget(angle, config.omega, angleTolerance);
            
            // If we're at omega and haven't counted this rep yet, and we're ready for next rep
            if (isAtOmega && !config.hasReachedOmega && config.isReadyForNextRep) {
              config.hasReachedOmega = true;
              config.repCount++;
              updateRepCounter();
              config.isReadyForNextRep = false; // Now we need to go back to alpha
            }
            
            // If we're back at alpha after reaching omega, we're ready for the next rep
            const isAtAlpha = isAngleCloseToTarget(angle, config.alpha, angleTolerance);
            if (isAtAlpha && config.hasReachedOmega && !config.isReadyForNextRep) {
              config.hasReachedOmega = false; // Reset for next rep
              config.isReadyForNextRep = true;
            }
          }
        }
      }
      
      // Update debug display after processing angles and states
      updateDebugDisplay();
    }
    
    // Add this function after the smoothAngle function
    function smoothKeypoints(currentKeypoints, previousKeypoints) {
      if (!previousKeypoints || !currentKeypoints) return currentKeypoints;
      
      // Create a deep copy of current keypoints to avoid modifying the original
      const smoothedKeypoints = JSON.parse(JSON.stringify(currentKeypoints));
      
      // Apply smoothing to each keypoint
      for (let i = 0; i < smoothedKeypoints.length; i++) {
        if (previousKeypoints[i] && smoothedKeypoints[i]) {
          // Only smooth if confidence is good
          if (smoothedKeypoints[i].score > 0.3) {
            smoothedKeypoints[i].x = positionSmoothingFactor * previousKeypoints[i].x + 
                                   (1 - positionSmoothingFactor) * smoothedKeypoints[i].x;
            smoothedKeypoints[i].y = positionSmoothingFactor * previousKeypoints[i].y + 
                                   (1 - positionSmoothingFactor) * smoothedKeypoints[i].y;
          }
        }
      }
      
      return smoothedKeypoints;
    }
    
    // Create a variable to store the previous keypoints
    let previousKeypoints = null;
    
    // Main detection and rendering loop
    async function detectAndRender() {
      if (!isRunning) return;
      
      try {
        // Set canvas dimensions to match video
        canvasEl.width = webcamEl.width;
        canvasEl.height = webcamEl.height;
        
        // Clear the canvas with transparent background
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        
        // Detect poses
        const poses = await detector.estimatePoses(webcamEl);
        
        // Check if any valid pose was detected
        let validPoseDetected = false;
        
        if (poses && poses.length > 0) {
          // Mirror the pose data
          poses.forEach(pose => {
            if (pose.keypoints && pose.keypoints.length > 0) {
              // Mirror the x coordinates
              pose.keypoints.forEach(keypoint => {
                keypoint.x = canvasEl.width - keypoint.x;
              });
              
              // Apply smoothing to keypoints
              pose.keypoints = smoothKeypoints(pose.keypoints, previousKeypoints);
              
              // Store current keypoints for next frame
              previousKeypoints = JSON.parse(JSON.stringify(pose.keypoints));
              
              // Check if we have enough valid keypoints for visualization
              let validKeypointsCount = 0;
              for (const joint in jointConfig) {
                if (jointConfig[joint].active) {
                  const config = jointConfig[joint];
                  const startPoint = pose.keypoints[config.keypoints.start];
                  const middlePoint = pose.keypoints[config.keypoints.middle];
                  const endPoint = pose.keypoints[config.keypoints.end];
                  
                  if (startPoint && middlePoint && endPoint && 
                      startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
                    validKeypointsCount++;
                    
                    // Calculate and update the angle for this joint
                    const angle = calculateAngle(startPoint, middlePoint, endPoint);
                    config.currentAngle = angle;
                    config.smoothedAngle = smoothAngle(angle, config.smoothedAngle || angle, smoothingFactor);
                  }
                }
              }
              
              if (validKeypointsCount > 0) {
                validPoseDetected = true;
                lastValidPoseTime = Date.now();
                
                // Process exercise state if we have a valid pose
                processExerciseState();
              }
            }
          });
        }
        
        // Now draw results and check if we need to show the message
        if (validPoseDetected) {
          drawResults(ctx, poses, canvasEl.width, canvasEl.height);
          updateUI();
          updateStateDisplay();
          updateDebugDisplay();
        } else {
          // Check if we should show the message or keep the last pose
          const currentTime = Date.now();
          if (currentTime - lastValidPoseTime > messageDelayThreshold) {
            // Show the message if we've waited long enough
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('Position your body clearly in view', canvasEl.width / 2, canvasEl.height / 2);
            updateStateDisplay();
            updateDebugDisplay();
          } else if (previousKeypoints) {
            // Create a fake pose with the previous keypoints to keep displaying
            const fakePose = { keypoints: previousKeypoints };
            drawResults(ctx, [fakePose], canvasEl.width, canvasEl.height);
            updateUI();
            updateStateDisplay();
            updateDebugDisplay();
          }
        }
        
        // Continue the loop
        requestAnimationFrame(detectAndRender);
      } catch (error) {
        console.error("Error in pose detection:", error);
        statusMessageEl.textContent = "Error: " + error.message;
        stopDetection();
      }
    }
    
    // Function to stop detection
    function stopDetection() {
      isRunning = false;
      // Additional cleanup if needed
    }
    
    // Start tracking
    async function startTracking() {
      try {
        // Hide the start button and show loading
        startButtonEl.style.display = 'none';
        loadingEl.style.display = 'flex';
        statusMessageEl.textContent = 'Setting up webcam...';
        
        // Setup webcam
        await setupWebcam();
        
        // Load pose model
        statusMessageEl.textContent = 'Loading pose detection model...';
        detector = await loadPoseDetectionModel();
        
        // Hide loading screen, show webcam
        loadingEl.style.display = 'none';
        webcamEl.style.display = 'block'; // Make sure webcam is visible
        
        // Create initial angle displays
        createAngleDisplays();
        
        // Start the detection loop
        isRunning = true;
        detectAndRender();
      } catch (error) {
        console.error('Error starting tracking:', error);
        statusMessageEl.textContent = 'Error starting tracking: ' + error.message;
        startButtonEl.style.display = 'block';
      }
    }
    
    // Initialize the app
    async function init() {
      try {
        // Check if TensorFlow.js is available
        if (typeof tf === 'undefined') {
          statusMessageEl.textContent = 'TensorFlow.js not loaded. Check your internet connection.';
          return;
        }
        
        // Load exercises first
        statusMessageEl.textContent = 'Loading exercises...';
        await loadExercises();
        
        // Show start button
        statusMessageEl.textContent = 'Ready to start. Click the button below.';
        startButtonEl.style.display = 'block';
        startButtonEl.addEventListener('click', startTracking);
        
        // Initialize rep counter
        updateRepCounter();

      } catch (error) {
        console.error('Error initializing:', error);
        statusMessageEl.textContent = 'Error initializing: ' + error.message;
      }
    }
    
    // Start when page is loaded
    window.onload = init;

    // Add this to your existing JavaScript
    function initializeDualSliders() {
      document.querySelectorAll('.dual-slider').forEach(slider => {
        const track = slider.querySelector('.slider-track');
        const range = slider.querySelector('.slider-range');
        const handles = slider.querySelectorAll('.slider-handle');
        const joint = slider.id.split('-slider')[0];
        
        let activeHandle = null;
        
        function updateSlider(handle, value) {
          const percent = (value / 180) * 100;
          handle.style.left = `${percent}%`;
          handle.dataset.value = value;
          
          // Update range bar
          const alpha = parseInt(handles[0].dataset.value);
          const omega = parseInt(handles[1].dataset.value);
          const left = Math.min(alpha, omega) / 180 * 100;
          const right = Math.max(alpha, omega) / 180 * 100;
          range.style.left = `${left}%`;
          range.style.width = `${right - left}%`;
          
          // Update value displays
          document.getElementById(`${joint}-alpha-value`).textContent = Math.round(alpha);
          document.getElementById(`${joint}-omega-value`).textContent = Math.round(omega);
          
          // Update joint config
          if (jointConfig[joint]) {
            if (handle.classList.contains('alpha')) {
              jointConfig[joint].alpha = value;
            } else {
              jointConfig[joint].omega = value;
            }
          }
        }
        
        handles.forEach(handle => {
          handle.addEventListener('mousedown', e => {
            e.preventDefault(); // Prevent text selection
            activeHandle = handle;
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', () => {
              activeHandle = null;
              document.removeEventListener('mousemove', handleDrag);
            });
          });
        });
        
        function handleDrag(e) {
          if (!activeHandle) return;
          
          const rect = track.getBoundingClientRect();
          let value = ((e.clientX - rect.left) / rect.width) * 180;
          value = Math.max(0, Math.min(180, value));
          updateSlider(activeHandle, value);
        }
        
        // Initialize positions
        handles.forEach(handle => {
          updateSlider(handle, parseInt(handle.dataset.value));
        });
      });
    }

    // Call this after your page loads
    document.addEventListener('DOMContentLoaded', () => {
      initializeDualSliders();
    });

    // Create a single global rep counter
    let globalRepCount = 0;

    // Update the rep counting mechanism
    let repState = {
      allJointsReady: false,
      allJointsCompleted: false,
      lastRepTime: 0 // Track time of last rep for debouncing
    };

    // Make sure jointConfig initialization doesn't include per-joint rep counts
    function initializeJointConfig() {
      // For each joint in the config
      for (const joint in jointConfig) {
        // Make sure both state flags are properly initialized
        jointConfig[joint].isReadyForNextRep = false; // Start as not ready
        jointConfig[joint].hasReachedOmega = false;
        // Remove individual joint rep counts
        if (jointConfig[joint].hasOwnProperty('repCount')) {
          delete jointConfig[joint].repCount;
        }
      }
    }

    // Initialize the rep counter display
    function updateRepCounter() {
      document.getElementById('rep-counter').textContent = globalRepCount;
    }

    // Update the rep counting function to maintain state correctly
    function updateRepCount() {
      // If we're using a predefined exercise, don't use the rep counter
      if (currentExercise) {
        return;
      }

      // Get all active joints
      const activeJoints = Object.keys(jointConfig).filter(joint => jointConfig[joint].active);
      
      if (activeJoints.length === 0) {
        // No active joints
        document.getElementById('state-status').textContent = "No joints selected";
        return;
      }
      
      // Check if all joints are at their Begin position (alpha)
      const allAtBegin = activeJoints.every(joint => {
        const angle = jointConfig[joint].smoothedAngle;
        return isAngleCloseToTarget(angle, jointConfig[joint].alpha, angleTolerance);
      });
      
      // Check if all joints are at their End position (omega)
      const allAtEnd = activeJoints.every(joint => {
        const angle = jointConfig[joint].smoothedAngle;
        return isAngleCloseToTarget(angle, jointConfig[joint].omega, angleTolerance);
      });
      
      // STATE MACHINE:
      
      // PHASE 1: Wait for all joints to reach Begin position
      if (allAtBegin && !repState.allJointsReady && !repState.allJointsCompleted) {
        repState.allJointsReady = true;
        console.log("All joints at BEGIN position - ready for rep");
      }
      
      // PHASE 2: All joints were at Begin, now all are at End - COUNT REP
      if (allAtEnd && repState.allJointsReady && !repState.allJointsCompleted) {
        const now = Date.now();
        if (now - repState.lastRepTime > 500) { // Debounce
          // Increment the global rep counter
          globalRepCount++;
          updateRepCounter();
          
          // Mark as completed
          repState.allJointsCompleted = true;
          repState.lastRepTime = now;
          console.log("Rep counted!");
        }
      }
      
      // PHASE 3: After counting a rep, wait for all joints to return to Begin before allowing next rep
      if (allAtBegin && repState.allJointsCompleted) {
        // Reset for next rep cycle
        repState.allJointsReady = true;
        repState.allJointsCompleted = false;
        console.log("Reset for next rep");
      }
      
      // Update the state display
      updateStateDisplay();
    }

    // Make sure the rep counter is initialized on page load
    document.addEventListener('DOMContentLoaded', function() {
      initializeJointConfig();
      globalRepCount = 0;
      updateRepCounter();
      // ... other initialization code ...
    });

    // Reset button functionality if you have one
    function resetRepCounter() {
      globalRepCount = 0;
      updateRepCounter();
    }

    // Add function to update the state display
    function updateStateDisplay() {
      const stateElement = document.getElementById('state-status');
      
      if (!stateElement) return;
      
      // Remove all state classes
      stateElement.classList.remove('state-waiting', 'state-ready', 'state-completed');
      
      if (currentExercise) {
        const stage = currentExercise[currentStage];
        const stateText = exerciseState.currentState === ExerciseState.WAITING_FOR_START ? 
          'Get to Start Position' : 'Move to End Position';
        
        stateElement.textContent = `${stage.name} - ${stateText}`;
        stateElement.classList.add(
          exerciseState.currentState === ExerciseState.WAITING_FOR_START ? 
          'state-waiting' : 'state-ready'
        );
      } else {
        // For custom exercise mode
        if (!repState.allJointsReady && !repState.allJointsCompleted) {
          stateElement.textContent = "Waiting for Begin";
          stateElement.classList.add('state-waiting');
        } 
        else if (repState.allJointsReady && !repState.allJointsCompleted) {
          stateElement.textContent = "Ready - Go to End";
          stateElement.classList.add('state-ready');
        }
        else if (repState.allJointsCompleted) {
          stateElement.textContent = "Completed - Return to Begin";
          stateElement.classList.add('state-completed');
        }
      }
    }

    // Check if ready to start current stage
    function isReadyForCurrentStage() {
      if (!currentExercise || currentStage >= currentExercise.length) return false;
      
      const stageInfo = currentExercise[currentStage];
      if (!stageInfo) {
        console.error('Invalid stage:', currentStage);
        return false;
      }

      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        console.error('No movements defined for stage:', stageInfo.name);
        return false;
      }
      
      // Check if all joint angles match starting angles within tolerance
      for (const [joint, angles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        if (!jointConfig[normalizedJoint]?.active) continue;
        
        const currentAngle = jointConfig[normalizedJoint].smoothedAngle;
        const startAngle = angles.start;
        
        // Use isAngleCloseToTarget with the global tolerance
        if (!isAngleCloseToTarget(currentAngle, startAngle, angleTolerance)) {
          console.log(`Joint ${normalizedJoint} not ready: current=${currentAngle}, target=${startAngle}, diff=${Math.abs(currentAngle - startAngle)}`);
          return false;
        }
      }
      
      return true;
    }

    // Check if current stage is complete
    function isCurrentStageComplete(pose) {
      if (!currentExercise || currentStage >= currentExercise.length) return false;
      
      const stageInfo = currentExercise[currentStage];
      if (!stageInfo) {
        console.error('Invalid stage:', currentStage);
        return false;
      }

      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        console.error('No movements defined for stage:', stageInfo.name);
        return false;
      }
      
      // Check if all joint angles match target end angles within tolerance
      for (const [joint, angles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        if (!jointConfig[normalizedJoint]?.active) continue;
        
        const currentAngle = jointConfig[normalizedJoint].smoothedAngle;
        const targetAngle = angles.end;
        
        // Use isAngleCloseToTarget with the global tolerance
        if (!isAngleCloseToTarget(currentAngle, targetAngle, angleTolerance)) {
          return false;
        }
      }
      
      // Add a debounce check to prevent rapid stage changes
      const now = Date.now();
      if (now - repState.lastRepTime < 500) { // Use the same debounce time as rep counting
        return false;
      }
      repState.lastRepTime = now;
      
      return true;
    }

    // Progress to next exercise stage
    function progressExerciseStage() {
      if (!currentExercise) return;
      
      currentStage++;
      if (currentStage >= currentExercise.length) {
        // Exercise complete, increment rep counter
        globalRepCount++;
        updateRepCounter();
        // Reset to beginning
        currentStage = 0;
      }
      
      handleExerciseStage(currentExercise, currentStage);
    }

    // Update the detectPose function to call our debug update
    async function detectPose() {
      try {
        const poses = await detector.estimatePoses(webcamEl);
        if (poses.length > 0) {
          const pose = poses[0];
          drawResults([pose], canvasEl.width, canvasEl.height);
          
          // Update debug display
          updateDebugDisplay();
          
          // Update state display
          updateStateDisplay();
          
          // Check if we should progress to next stage for predefined exercises
          if (currentExercise && isCurrentStageComplete(pose)) {
            progressExerciseStage();
          }
        }
        requestAnimationFrame(detectPose);
      } catch (error) {
        console.error('Error in pose detection:', error);
        requestAnimationFrame(detectPose);
      }
    }

    // Update joint UI elements
    function updateJointUI(joint, angles) {
      // Update value displays
      const alphaValue = document.getElementById(`${joint}-alpha-value`);
      const omegaValue = document.getElementById(`${joint}-omega-value`);
      if (alphaValue) alphaValue.textContent = angles.start;
      if (omegaValue) omegaValue.textContent = angles.end;
      
      // Update slider handles
      const alphaHandle = document.querySelector(`#${joint}-slider .slider-handle.alpha`);
      const omegaHandle = document.querySelector(`#${joint}-slider .slider-handle.omega`);
      if (alphaHandle) {
        alphaHandle.style.left = `${(angles.start / 180) * 100}%`;
        alphaHandle.dataset.value = angles.start;
      }
      if (omegaHandle) {
        omegaHandle.style.left = `${(angles.end / 180) * 100}%`;
        omegaHandle.dataset.value = angles.end;
      }
      
      // Update range bar
      const range = document.querySelector(`#${joint}-slider .slider-range`);
      if (range) {
        const left = Math.min(angles.start, angles.end) / 180 * 100;
        const right = Math.max(angles.start, angles.end) / 180 * 100;
        range.style.left = `${left}%`;
        range.style.width = `${right - left}%`;
      }
    }

    // Add state machine constants
    const ExerciseState = {
      WAITING_FOR_START: 'waiting_for_start',
      READY_FOR_END: 'ready_for_end'
    };

    // Add state machine to exercise state tracking
    let exerciseState = {
      currentState: ExerciseState.WAITING_FOR_START,
      lastStateChangeTime: 0
    };

    // Check if all active joints are at their start positions
    function checkStartPositions() {
      if (!currentExercise || !currentExercise[currentStage]) return false;
      
      const stageInfo = currentExercise[currentStage];
      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        console.error('No movements defined for stage:', stageInfo.name);
        return false;
      }

      for (const [joint, targetAngles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        if (!jointConfig[normalizedJoint]?.active) continue;

        const currentAngle = jointConfig[normalizedJoint].smoothedAngle || 0;
        const startAngle = targetAngles.start;
        const diffFromStart = Math.abs(currentAngle - startAngle);

        if (diffFromStart > angleTolerance) {
          return false;
        }
      }
      return true;
    }

    // Check if all active joints are at their end positions
    function checkEndPositions() {
      if (!currentExercise || !currentExercise[currentStage]) return false;
      
      const stageInfo = currentExercise[currentStage];
      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        console.error('No movements defined for stage:', stageInfo.name);
        return false;
      }

      for (const [joint, targetAngles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        if (!jointConfig[normalizedJoint]?.active) continue;

        const currentAngle = jointConfig[normalizedJoint].smoothedAngle || 0;
        const endAngle = targetAngles.end;
        const diffFromEnd = Math.abs(currentAngle - endAngle);

        if (diffFromEnd > angleTolerance) {
          return false;
        }
      }
      return true;
    }

    // Update state display
    function updateStateDisplay() {
      const stateElement = document.getElementById('state-status');
      
      if (!stateElement) return;
      
      // Remove all state classes
      stateElement.classList.remove('state-waiting', 'state-ready', 'state-completed');
      
      if (currentExercise) {
        const stage = currentExercise[currentStage];
        
        switch (exerciseState.currentState) {
          case ExerciseState.WAITING_FOR_START:
            stateElement.textContent = `Get Ready - ${stage.name}`;
            stateElement.classList.add('state-waiting');
            break;
          case ExerciseState.READY_FOR_END:
            stateElement.textContent = `Move to End - ${stage.name}`;
            stateElement.classList.add('state-ready');
            break;
        }
      } else {
        // For custom exercise mode
        if (!repState.allJointsReady && !repState.allJointsCompleted) {
          stateElement.textContent = "Waiting for Begin";
          stateElement.classList.add('state-waiting');
        } 
        else if (repState.allJointsReady && !repState.allJointsCompleted) {
          stateElement.textContent = "Ready - Go to End";
          stateElement.classList.add('state-ready');
        }
        else if (repState.allJointsCompleted) {
          stateElement.textContent = "Completed - Return to Begin";
          stateElement.classList.add('state-completed');
        }
      }
    }

    // Update the debug display to show current state
    function updateDebugDisplay() {
      const debugCurrentState = document.getElementById('debug-current-state');
      const debugConditions = document.getElementById('debug-conditions');
      const debugAngles = document.getElementById('debug-angles');

      if (!currentExercise) {
        debugCurrentState.textContent = "No exercise selected";
        debugConditions.textContent = "N/A";
        debugAngles.textContent = "N/A";
        return;
      }

      const stageInfo = currentExercise[currentStage];
      if (!stageInfo) {
        debugCurrentState.textContent = "Invalid stage";
        debugConditions.textContent = "N/A";
        debugAngles.textContent = "N/A";
        return;
      }
      
      // Update current state info
      const stateInfo = {
        'Exercise': document.getElementById('exercise-selector').value,
        'Current Stage': currentStage,
        'Stage Name': stageInfo.name,
        'Stage Type': stageInfo.type,
        'Current State': exerciseState.currentState,
        'Tolerance': angleTolerance + '°'
      };
      debugCurrentState.textContent = JSON.stringify(stateInfo, null, 2);

      // Get movements from either movements property or hold.joints for hold stages
      const movements = stageInfo.type === 'hold' 
        ? Object.entries(stageInfo.hold.joints).reduce((acc, [joint, config]) => {
            acc[joint] = { start: config.angle, end: config.angle };
            return acc;
          }, {})
        : stageInfo.movements;

      if (!movements) {
        debugConditions.textContent = "No movements defined for stage";
        debugAngles.textContent = "N/A";
        return;
      }

      // Check and display all conditions
      const conditions = [];
      const anglesList = [];
      
      for (const [joint, targetAngles] of Object.entries(movements)) {
        const normalizedJoint = joint.replace('_', '-');
        if (!jointConfig[normalizedJoint]?.active) continue;

        const currentAngle = jointConfig[normalizedJoint].smoothedAngle || 0;
        const startAngle = targetAngles.start;
        const endAngle = targetAngles.end;
        const diffFromStart = Math.abs(currentAngle - startAngle);
        const diffFromEnd = Math.abs(currentAngle - endAngle);

        // Add angle information
        anglesList.push({
          joint: normalizedJoint,
          current: Math.round(currentAngle) + '°',
          target: {
            start: startAngle + '°',
            end: endAngle + '°'
          },
          differences: {
            fromStart: Math.round(diffFromStart) + '°',
            fromEnd: Math.round(diffFromEnd) + '°'
          }
        });

        // Add condition information based on current state and stage type
        if (stageInfo.type === 'hold') {
          conditions.push({
            description: `${normalizedJoint} at hold angle (${startAngle}° ±${angleTolerance}°)`,
            met: diffFromStart <= angleTolerance,
            current: Math.round(currentAngle) + '°',
            diff: Math.round(diffFromStart) + '°'
          });
        } else {
          // For movement stages, show condition based on current state
          if (exerciseState.currentState === ExerciseState.WAITING_FOR_START) {
            conditions.push({
              description: `${normalizedJoint} at start position (${startAngle}° ±${angleTolerance}°)`,
              met: diffFromStart <= angleTolerance,
              current: Math.round(currentAngle) + '°',
              diff: Math.round(diffFromStart) + '°'
            });
          } else {
            conditions.push({
              description: `${normalizedJoint} at end position (${endAngle}° ±${angleTolerance}°)`,
              met: diffFromEnd <= angleTolerance,
              current: Math.round(currentAngle) + '°',
              diff: Math.round(diffFromEnd) + '°'
            });
          }
        }
      }

      // Format conditions with colored status
      const formattedConditions = conditions.map(c => 
        `${c.met ? '✓' : '✗'} ${c.description}\n` +
        `  Current: ${c.current}, Diff: ${c.diff}` +
        `  ${c.met ? '(MET)' : '(NOT MET)'}`
      ).join('\n\n');

      debugConditions.textContent = formattedConditions || "Waiting for pose detection...";
      debugAngles.textContent = JSON.stringify(anglesList, null, 2);
    }

    // Update the main detection loop to handle state transitions
    function processExerciseState() {
      if (!currentExercise) return;

      const now = Date.now();
      const timeSinceLastChange = now - exerciseState.lastStateChangeTime;
      
      switch (exerciseState.currentState) {
        case ExerciseState.WAITING_FOR_START:
          if (checkStartPositions() && timeSinceLastChange > 500) {
            exerciseState.currentState = ExerciseState.READY_FOR_END;
            exerciseState.lastStateChangeTime = now;
            console.log('Transitioned to READY_FOR_END state');
            updateStateDisplay();
          }
          break;
          
        case ExerciseState.READY_FOR_END:
          if (checkEndPositions() && timeSinceLastChange > 500) {
            // Check if this was the last stage of the exercise
            if (currentStage === currentExercise.length - 1) {
              // Only increment rep count when completing the full exercise
              globalRepCount++;
              updateRepCounter();
            }
            
            // Move to next stage or reset to first stage
            currentStage++;
            if (currentStage >= currentExercise.length) {
              currentStage = 0;
            }
            
            // Configure the new stage
            handleExerciseStage(currentExercise, currentStage);
            console.log('Completed stage, moved to next stage');
            updateStateDisplay();
          }
          break;
      }
    }

    // Add variable for rolling average duration
    let rollingAverageDuration = 5000; // 5 seconds in milliseconds
    
    // Add the rolling average duration control elements
    const rollingAverageDurationSlider = document.getElementById('rolling-average-duration');
    const rollingAverageDurationValue = document.getElementById('rolling-average-duration-value');
    
    // Setup rolling average duration control event listeners
    rollingAverageDurationSlider.addEventListener('input', function() {
      const value = parseFloat(this.value);
      rollingAverageDuration = value * 1000; // Convert to milliseconds
      rollingAverageDurationValue.textContent = value;
    });
  </script>
</body>
</html>