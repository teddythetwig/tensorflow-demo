<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpha-Omega Left Elbow Angle Tracker</title>
  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
  <!-- Load MoveNet model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: white;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      margin-bottom: 20px;
      aspect-ratio: 4/3;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    #webcam {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      background-color: #000;
      z-index: 1;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      background-color: transparent;
    }
    
    .controls {
      background-color: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
    }
    
    .controls h3 {
      margin-top: 0;
      margin-bottom: 16px;
      font-size: 18px;
    }
    
    .metrics {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    
    .metric {
      text-align: left;
    }
    
    .metric-label {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: bold;
    }
    
    .metric-value.in-range {
      color: #4ade80;
    }
    
    .metric-value.out-range {
      color: #fbbf24;
    }
    
    .progress-bar {
      width: 100%;
      height: 24px;
      background-color: #3a3a3a;
      border-radius: 9999px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(to right, #3b82f6, #4ade80);
      transition: width 0.3s ease-in-out;
    }
    
    .note {
      font-size: 12px;
      color: #aaa;
    }
    
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 300px;
      background-color: #1a1a1a;
      margin-bottom: 20px;
      border-radius: 8px;
    }
    
    .loading-icon {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid #fff;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #status-message {
      margin-top: 10px;
      text-align: center;
    }

    button {
      background-color: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    button:hover {
      background-color: #2563eb;
    }
    
    .angle-controls {
      background-color: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
      margin-bottom: 16px;
    }
    
    .angle-control {
      margin-bottom: 10px;
    }
    
    .angle-control label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
    }
    
    .slider-container input[type="range"] {
      flex-grow: 1;
      margin-right: 10px;
    }
    
    .slider-container input[type="number"] {
      width: 60px;
      background-color: #3a3a3a;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 5px;
    }
    
    .presets {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    
    .preset-button {
      background-color: #3a3a3a;
      border: 1px solid #555;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .preset-button:hover {
      background-color: #4a4a4a;
    }

    .rep-counter-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3;
      pointer-events: none; /* Allow interaction with elements below */
    }

    .current-angle {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 32px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 8px;
      font-weight: bold;
    }

    .rep-count {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 48px;
      color: white;
      background-color: rgba(59, 130, 246, 0.7);
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
    }
    
    .tab-button {
      background-color: #333;
      color: #aaa;
      border: none;
      padding: 8px 12px;
      margin-right: 2px;
      cursor: pointer;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .tab-button:hover {
      background-color: #444;
      color: white;
    }
    
    .tab-button.active {
      background-color: #2a2a2a;
      color: white;
      border-bottom: 2px solid #3b82f6;
    }
    
    .tab-content {
      background-color: #2a2a2a;
      border-radius: 0 0 8px 8px;
      padding: 16px;
    }
    
    .tab-pane {
      display: none;
    }
    
    .tab-pane.active {
      display: block;
    }
    
    .compact-presets {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
    
    .compact-presets .preset-button {
      font-size: 12px;
      padding: 5px 8px;
    }
    
    .global-controls {
      margin-top: 16px;
      background-color: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
    }
    
    .joint-angle-displays {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .joint-angle {
      font-size: 24px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
    }

    .joint-toggles {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .toggle-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }
    
    .toggle-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      background-color: #333;
      border-radius: 6px;
      transition: background-color 0.2s;
    }
    
    .toggle-label:hover {
      background-color: #444;
    }
    
    .toggle-label input[type="checkbox"] {
      margin-right: 8px;
      width: 16px;
      height: 16px;
    }
    
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: auto;
    }
    
    .joint-name {
      font-size: 14px;
    }
    
    .joint-settings {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 16px;
    }
    
    .joint-setting {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
    }
    
    .joint-setting h3 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 16px;
      border-bottom: 1px solid #444;
      padding-bottom: 8px;
    }
    
    .angle-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .angle-control {
      margin-bottom: 8px;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .slider-container input[type="range"] {
      flex: 1;
    }
    
    .slider-container input[type="number"] {
      width: 60px;
    }
    
    .compact-presets {
      display: flex;
      gap: 6px;
    }
    
    .preset-button {
      font-size: 12px;
      padding: 4px 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Joint Angle Tracker</h2>
    
    <!-- Joint Angle Controls -->
    <div class="joint-controls">
      <div class="joint-toggles">
        <h3>Select Joints to Track</h3>
        <div class="toggle-grid">
          <label class="toggle-label">
            <input type="checkbox" data-joint="left-elbow" checked>
            <span class="joint-name">Left Elbow</span>
            <span class="color-dot" style="background-color: rgb(59, 130, 246);"></span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" data-joint="right-elbow">
            <span class="joint-name">Right Elbow</span>
            <span class="color-dot" style="background-color: rgb(239, 68, 68);"></span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" data-joint="left-shoulder">
            <span class="joint-name">Left Shoulder</span>
            <span class="color-dot" style="background-color: rgb(16, 185, 129);"></span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" data-joint="right-shoulder">
            <span class="joint-name">Right Shoulder</span>
            <span class="color-dot" style="background-color: rgb(249, 115, 22);"></span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" data-joint="left-knee">
            <span class="joint-name">Left Knee</span>
            <span class="color-dot" style="background-color: rgb(139, 92, 246);"></span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" data-joint="right-knee">
            <span class="joint-name">Right Knee</span>
            <span class="color-dot" style="background-color: rgb(236, 72, 153);"></span>
          </label>
        </div>
      </div>
      
      <div class="joint-settings">
        <!-- Left Elbow Settings -->
        <div class="joint-setting" id="left-elbow-settings">
          <h3>Left Elbow</h3>
          <div class="angle-controls">
            <div class="angle-control">
              <label for="left-elbow-alpha">Alpha: <span id="left-elbow-alpha-value">160</span>°</label>
              <div class="slider-container">
                <input type="range" id="left-elbow-alpha" min="0" max="180" value="160" step="1" data-joint="left-elbow" data-param="alpha">
                <input type="number" id="left-elbow-alpha-input" min="0" max="180" value="160" data-joint="left-elbow" data-param="alpha">
              </div>
            </div>
            <div class="angle-control">
              <label for="left-elbow-omega">Omega: <span id="left-elbow-omega-value">45</span>°</label>
              <div class="slider-container">
                <input type="range" id="left-elbow-omega" min="0" max="180" value="45" step="1" data-joint="left-elbow" data-param="omega">
                <input type="number" id="left-elbow-omega-input" min="0" max="180" value="45" data-joint="left-elbow" data-param="omega">
              </div>
            </div>
            <div class="compact-presets">
              <button class="preset-button" data-joint="left-elbow" data-alpha="160" data-omega="45">160°→45°</button>
              <button class="preset-button" data-joint="left-elbow" data-alpha="45" data-omega="160">45°→160°</button>
            </div>
          </div>
        </div>
        
        <!-- Right Elbow Settings -->
        <div class="joint-setting" id="right-elbow-settings">
          <h3>Right Elbow</h3>
          <div class="angle-controls">
            <div class="angle-control">
              <label for="right-elbow-alpha">Alpha: <span id="right-elbow-alpha-value">160</span>°</label>
              <div class="slider-container">
                <input type="range" id="right-elbow-alpha" min="0" max="180" value="160" step="1" data-joint="right-elbow" data-param="alpha">
                <input type="number" id="right-elbow-alpha-input" min="0" max="180" value="160" data-joint="right-elbow" data-param="alpha">
              </div>
            </div>
            <div class="angle-control">
              <label for="right-elbow-omega">Omega: <span id="right-elbow-omega-value">45</span>°</label>
              <div class="slider-container">
                <input type="range" id="right-elbow-omega" min="0" max="180" value="45" step="1" data-joint="right-elbow" data-param="omega">
                <input type="number" id="right-elbow-omega-input" min="0" max="180" value="45" data-joint="right-elbow" data-param="omega">
              </div>
            </div>
            <div class="compact-presets">
              <button class="preset-button" data-joint="right-elbow" data-alpha="160" data-omega="45">160°→45°</button>
              <button class="preset-button" data-joint="right-elbow" data-alpha="45" data-omega="160">45°→160°</button>
            </div>
          </div>
        </div>
        
        <!-- Left Shoulder Settings -->
        <div class="joint-setting" id="left-shoulder-settings">
          <h3>Left Shoulder</h3>
          <div class="angle-controls">
            <div class="angle-control">
              <label for="left-shoulder-alpha">Alpha: <span id="left-shoulder-alpha-value">90</span>°</label>
              <div class="slider-container">
                <input type="range" id="left-shoulder-alpha" min="0" max="180" value="90" step="1" data-joint="left-shoulder" data-param="alpha">
                <input type="number" id="left-shoulder-alpha-input" min="0" max="180" value="90" data-joint="left-shoulder" data-param="alpha">
              </div>
            </div>
            <div class="angle-control">
              <label for="left-shoulder-omega">Omega: <span id="left-shoulder-omega-value">180</span>°</label>
              <div class="slider-container">
                <input type="range" id="left-shoulder-omega" min="0" max="180" value="180" step="1" data-joint="left-shoulder" data-param="omega">
                <input type="number" id="left-shoulder-omega-input" min="0" max="180" value="180" data-joint="left-shoulder" data-param="omega">
              </div>
            </div>
            <div class="compact-presets">
              <button class="preset-button" data-joint="left-shoulder" data-alpha="90" data-omega="180">90°→180°</button>
              <button class="preset-button" data-joint="left-shoulder" data-alpha="180" data-omega="90">180°→90°</button>
            </div>
          </div>
        </div>
        
        <!-- Right Shoulder Settings -->
        <div class="joint-setting" id="right-shoulder-settings">
          <h3>Right Shoulder</h3>
          <div class="angle-controls">
            <div class="angle-control">
              <label for="right-shoulder-alpha">Alpha: <span id="right-shoulder-alpha-value">90</span>°</label>
              <div class="slider-container">
                <input type="range" id="right-shoulder-alpha" min="0" max="180" value="90" step="1" data-joint="right-shoulder" data-param="alpha">
                <input type="number" id="right-shoulder-alpha-input" min="0" max="180" value="90" data-joint="right-shoulder" data-param="alpha">
              </div>
            </div>
            <div class="angle-control">
              <label for="right-shoulder-omega">Omega: <span id="right-shoulder-omega-value">180</span>°</label>
              <div class="slider-container">
                <input type="range" id="right-shoulder-omega" min="0" max="180" value="180" step="1" data-joint="right-shoulder" data-param="omega">
                <input type="number" id="right-shoulder-omega-input" min="0" max="180" value="180" data-joint="right-shoulder" data-param="omega">
              </div>
            </div>
            <div class="compact-presets">
              <button class="preset-button" data-joint="right-shoulder" data-alpha="90" data-omega="180">90°→180°</button>
              <button class="preset-button" data-joint="right-shoulder" data-alpha="180" data-omega="90">180°→90°</button>
            </div>
          </div>
        </div>
        
        <!-- Left Knee Settings -->
        <div class="joint-setting" id="left-knee-settings">
          <h3>Left Knee</h3>
          <div class="angle-controls">
            <div class="angle-control">
              <label for="left-knee-alpha">Alpha: <span id="left-knee-alpha-value">170</span>°</label>
              <div class="slider-container">
                <input type="range" id="left-knee-alpha" min="0" max="180" value="170" step="1" data-joint="left-knee" data-param="alpha">
                <input type="number" id="left-knee-alpha-input" min="0" max="180" value="170" data-joint="left-knee" data-param="alpha">
              </div>
            </div>
            <div class="angle-control">
              <label for="left-knee-omega">Omega: <span id="left-knee-omega-value">90</span>°</label>
              <div class="slider-container">
                <input type="range" id="left-knee-omega" min="0" max="180" value="90" step="1" data-joint="left-knee" data-param="omega">
                <input type="number" id="left-knee-omega-input" min="0" max="180" value="90" data-joint="left-knee" data-param="omega">
              </div>
            </div>
            <div class="compact-presets">
              <button class="preset-button" data-joint="left-knee" data-alpha="170" data-omega="90">170°→90°</button>
              <button class="preset-button" data-joint="left-knee" data-alpha="90" data-omega="170">90°→170°</button>
            </div>
          </div>
        </div>
        
        <!-- Right Knee Settings -->
        <div class="joint-setting" id="right-knee-settings">
          <h3>Right Knee</h3>
          <div class="angle-controls">
            <div class="angle-control">
              <label for="right-knee-alpha">Alpha: <span id="right-knee-alpha-value">170</span>°</label>
              <div class="slider-container">
                <input type="range" id="right-knee-alpha" min="0" max="180" value="170" step="1" data-joint="right-knee" data-param="alpha">
                <input type="number" id="right-knee-alpha-input" min="0" max="180" value="170" data-joint="right-knee" data-param="alpha">
              </div>
            </div>
            <div class="angle-control">
              <label for="right-knee-omega">Omega: <span id="right-knee-omega-value">90</span>°</label>
              <div class="slider-container">
                <input type="range" id="right-knee-omega" min="0" max="180" value="90" step="1" data-joint="right-knee" data-param="omega">
                <input type="number" id="right-knee-omega-input" min="0" max="180" value="90" data-joint="right-knee" data-param="omega">
              </div>
            </div>
            <div class="compact-presets">
              <button class="preset-button" data-joint="right-knee" data-alpha="170" data-omega="90">170°→90°</button>
              <button class="preset-button" data-joint="right-knee" data-alpha="90" data-omega="170">90°→170°</button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="global-controls">
        <div class="angle-control">
          <label for="angle-tolerance">Detection Tolerance: <span id="angle-tolerance-value">10</span>°</label>
          <div class="slider-container">
            <input type="range" id="angle-tolerance" min="1" max="30" value="10" step="1">
            <input type="number" id="angle-tolerance-input" min="1" max="30" value="10">
          </div>
        </div>
      </div>
    </div>
    
    <div id="loading" class="loading">
      <div class="loading-icon"></div>
      <p id="status-message">Loading TensorFlow.js...</p>
      <button id="start-button" style="display: none;">Start Tracking</button>
    </div>
    
    <div class="video-container">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
      
      <div class="rep-counter-overlay">
        <div class="joint-angle-displays">
          <!-- These will be dynamically populated based on active joints -->
        </div>
        <div class="rep-count">
          <span id="rep-counter">0</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Joint Configuration Data Structure
    const jointConfig = {
      'left-elbow': {
        alpha: 160,
        omega: 45,
        keypoints: { // MoveNet keypoint indices
          start: 5, // left shoulder
          middle: 7, // left elbow
          end: 9 // left wrist
        },
        color: 'rgb(59, 130, 246)', // blue
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: true,
        currentAngle: 0,
        smoothedAngle: 0,
        active: true // This is the default active joint
      },
      'right-elbow': {
        alpha: 160,
        omega: 45,
        keypoints: {
          start: 6, // right shoulder
          middle: 8, // right elbow
          end: 10 // right wrist
        },
        color: 'rgb(239, 68, 68)', // red
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: true,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'left-shoulder': {
        alpha: 90,
        omega: 180,
        keypoints: {
          start: 11, // left hip
          middle: 5, // left shoulder
          end: 7 // left elbow
        },
        color: 'rgb(16, 185, 129)', // green
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: true,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'right-shoulder': {
        alpha: 90,
        omega: 180,
        keypoints: {
          start: 12, // right hip
          middle: 6, // right shoulder
          end: 8 // right elbow
        },
        color: 'rgb(249, 115, 22)', // orange
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: true,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'left-knee': {
        alpha: 170,
        omega: 90,
        keypoints: {
          start: 11, // left hip
          middle: 13, // left knee
          end: 15 // left ankle
        },
        color: 'rgb(139, 92, 246)', // purple
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: true,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      },
      'right-knee': {
        alpha: 170,
        omega: 90,
        keypoints: {
          start: 12, // right hip
          middle: 14, // right knee
          end: 16 // right ankle
        },
        color: 'rgb(236, 72, 153)', // pink
        repCount: 0,
        hasReachedOmega: false,
        isReadyForNextRep: true,
        currentAngle: 0,
        smoothedAngle: 0,
        active: false
      }
    };

    // DOM Elements
    const webcamEl = document.getElementById('webcam');
    const canvasEl = document.getElementById('canvas');
    const loadingEl = document.getElementById('loading');
    const startButtonEl = document.getElementById('start-button');
    const statusMessageEl = document.getElementById('status-message');
    const repCounterEl = document.getElementById('rep-counter');
    const jointToggles = document.querySelectorAll('input[type="checkbox"][data-joint]');
    const jointAngleDisplaysEl = document.querySelector('.joint-angle-displays');
    
    // Add variable for tolerance
    let angleTolerance = 10; // Default tolerance in degrees
    
    // Add the tolerance control elements
    const angleToleranceSlider = document.getElementById('angle-tolerance');
    const angleToleranceInput = document.getElementById('angle-tolerance-input');
    const angleToleranceValue = document.getElementById('angle-tolerance-value');
    
    // Setup tolerance control event listeners
    angleToleranceSlider.addEventListener('input', function() {
      const value = parseInt(this.value);
      angleTolerance = value;
      angleToleranceValue.textContent = value;
      angleToleranceInput.value = value;
    });
    
    angleToleranceInput.addEventListener('change', function() {
      const value = parseInt(this.value);
      
      // Validate input
      if (isNaN(value) || value < 1) {
        this.value = 1;
        angleTolerance = 1;
      } else if (value > 30) {
        this.value = 30;
        angleTolerance = 30;
      } else {
        angleTolerance = value;
      }
      
      angleToleranceSlider.value = angleTolerance;
      angleToleranceValue.textContent = angleTolerance;
    });
    
    // Tracking state
    let detector;
    let smoothingFactor = 0.85; // For angle smoothing
    let positionSmoothingFactor = 0.7; // For keypoint position smoothing
    let isRunning = false;
    let activeJoint = 'left-elbow'; // Default active joint
    let lastValidPoseTime = 0; // Timestamp of last valid pose detection
    const messageDelayThreshold = 2000; // Time in ms before showing "Position your body" message
    
    // Setup joint toggle event listeners
    jointToggles.forEach(toggle => {
      // Set initial state based on the checkbox
      const jointId = toggle.getAttribute('data-joint');
      if (jointConfig[jointId]) {
        jointConfig[jointId].active = toggle.checked;
      }
      
      // Add event listener for changes
      toggle.addEventListener('change', () => {
        const jointId = toggle.getAttribute('data-joint');
        if (jointConfig[jointId]) {
          jointConfig[jointId].active = toggle.checked;
          updateAngleDisplays();
        }
      });
    });
    
    // Setup all range inputs using delegation and data attributes for DRY code
    document.addEventListener('input', function(e) {
      if (e.target.matches('input[type="range"][data-joint][data-param]')) {
        const joint = e.target.getAttribute('data-joint');
        const param = e.target.getAttribute('data-param');
        const value = parseInt(e.target.value);
        
        // Update the config
        jointConfig[joint][param] = value;
        
        // Update the display and number input
        document.getElementById(`${joint}-${param}-value`).textContent = value;
        document.getElementById(`${joint}-${param}-input`).value = value;
      }
    });
    
    // Setup all number inputs
    document.addEventListener('change', function(e) {
      if (e.target.matches('input[type="number"][data-joint][data-param]')) {
        const joint = e.target.getAttribute('data-joint');
        const param = e.target.getAttribute('data-param');
        let value = parseInt(e.target.value);
        
        // Validate input
        if (isNaN(value) || value < 0) {
          value = 0;
        } else if (value > 180) {
          value = 180;
        }
        
        // Update the value
        e.target.value = value;
        jointConfig[joint][param] = value;
        
        // Update the display and range input
        document.getElementById(`${joint}-${param}-value`).textContent = value;
        document.getElementById(`${joint}-${param}`).value = value;
      }
    });
    
    // Setup preset buttons
    document.addEventListener('click', function(e) {
      if (e.target.matches('.preset-button[data-joint]')) {
        const joint = e.target.getAttribute('data-joint');
        const alpha = parseInt(e.target.getAttribute('data-alpha'));
        const omega = parseInt(e.target.getAttribute('data-omega'));
        
        // Update the config
        jointConfig[joint].alpha = alpha;
        jointConfig[joint].omega = omega;
        
        // Update all UI elements
        document.getElementById(`${joint}-alpha-value`).textContent = alpha;
        document.getElementById(`${joint}-omega-value`).textContent = omega;
        document.getElementById(`${joint}-alpha`).value = alpha;
        document.getElementById(`${joint}-omega`).value = omega;
        document.getElementById(`${joint}-alpha-input`).value = alpha;
        document.getElementById(`${joint}-omega-input`).value = omega;
      }
    });
    
    // Canvas setup
    const ctx = canvasEl.getContext('2d');
    
    // Initialize the webcam
    async function setupWebcam() {
      return new Promise((resolve, reject) => {
        navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        })
        .then(stream => {
          webcamEl.srcObject = stream;
          webcamEl.onloadedmetadata = () => {
            webcamEl.width = webcamEl.videoWidth;
            webcamEl.height = webcamEl.videoHeight;
            resolve(webcamEl);
          };
        })
        .catch(error => {
          statusMessageEl.textContent = 'Error accessing webcam: ' + error.message;
          reject(error);
        });
      });
    }
    
    // Load the pose detection model - using MoveNet which is more reliable in browsers
    async function loadPoseDetectionModel() {
      try {
        // Use MoveNet SinglePose - more reliable than BlazePose in browser environments
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          enableSmoothing: true
        };
        
        return await poseDetection.createDetector(model, detectorConfig);
      } catch (error) {
        console.error('Error loading model:', error);
        statusMessageEl.textContent = 'Error loading model: ' + error.message;
        throw error;
      }
    }
    
    // Calculate angle between three points
    function calculateAngle(a, b, c) {
      // Vector BA
      const ba = { x: a.x - b.x, y: a.y - b.y };
      // Vector BC
      const bc = { x: c.x - b.x, y: c.y - b.y };
      
      // Dot product and magnitudes
      const dotProduct = ba.x * bc.x + ba.y * bc.y;
      const baMagnitude = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
      const bcMagnitude = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
      
      // Cosine of angle
      const cosAngle = dotProduct / (baMagnitude * bcMagnitude);
      
      // Convert to degrees
      let angleDegrees = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
      
      return angleDegrees;
    }
    
    // Find angle in radians on the unit circle
    function getAngleRadians(x, y) {
      return Math.atan2(y, x);
    }
    
    // Check if current angle is between alpha and omega, considering direction
    function isAngleInRange(currentAngle, alpha, omega) {
      // If alpha <= omega, we're moving in the increasing direction
      if (alpha <= omega) {
        return currentAngle >= alpha && currentAngle <= omega;
      } 
      // If alpha > omega, we're moving in the decreasing direction
      else {
        return currentAngle <= alpha && currentAngle >= omega;
      }
    }
    
    // Smooth angle using exponential moving average
    function smoothAngle(currentAngle, previousSmoothedAngle, smoothingFactor) {
      return smoothingFactor * previousSmoothedAngle + (1 - smoothingFactor) * currentAngle;
    }
    
    // Helper function to check if an angle is within a certain range of a target
    function isAngleCloseToTarget(angle, target, tolerance) {
      return Math.abs(angle - target) <= tolerance;
    }
    
    // Function to update the rep counter display
    function updateRepCounter() {
      // Sum up reps from all active joints
      let totalReps = 0;
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          totalReps += jointConfig[joint].repCount;
        }
      }
      repCounterEl.textContent = totalReps;
    }
    
    // Create angle display elements for each joint
    function createAngleDisplays() {
      // Clear existing displays
      jointAngleDisplaysEl.innerHTML = '';
      
      // Create an element for each active joint
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          const jointDisplay = document.createElement('div');
          jointDisplay.classList.add('joint-angle');
          jointDisplay.id = `${joint}-display`;
          jointDisplay.style.color = jointConfig[joint].color;
          jointDisplay.innerHTML = `<span>${joint.replace('-', ' ')}: </span><span id="${joint}-angle">0°</span>`;
          jointAngleDisplaysEl.appendChild(jointDisplay);
        }
      }
    }
    
    // Update angle displays
    function updateAngleDisplays() {
      // First make sure displays exist for active joints
      createAngleDisplays();
      
      // Update each display with current angle
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          const displayEl = document.getElementById(`${joint}-angle`);
          if (displayEl) {
            displayEl.textContent = `${Math.round(jointConfig[joint].smoothedAngle)}°`;
          }
        }
      }
    }
    
    // Draw angle visualization for a specific joint
    function drawAngleVisualization(ctx, joint, keypoints) {
      const config = jointConfig[joint];
      const startPoint = keypoints[config.keypoints.start];
      const middlePoint = keypoints[config.keypoints.middle];
      const endPoint = keypoints[config.keypoints.end];
      
      // Make sure all keypoints are present with good confidence
      if (startPoint && middlePoint && endPoint && 
          startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
        
        // Calculate vectors
        const vectorA = { 
          x: startPoint.x - middlePoint.x, 
          y: startPoint.y - middlePoint.y 
        };
        const vectorB = { 
          x: endPoint.x - middlePoint.x, 
          y: endPoint.y - middlePoint.y 
        };
        
        // Get the angle in radians
        const angleA = getAngleRadians(vectorA.x, vectorA.y);
        const angleB = getAngleRadians(vectorB.x, vectorB.y);
        
        // Radius for drawing arcs
        const radius = 30;
        
        // Calculate cross product to determine the direction
        const crossProduct = vectorA.x * vectorB.y - vectorA.y * vectorB.x;

        // Calculate the actual angle between vectors (0 to 180 degrees)
        const angleBetweenVectors = Math.acos(
          (vectorA.x * vectorB.x + vectorA.y * vectorB.y) / 
          (Math.sqrt(vectorA.x * vectorA.x + vectorA.y * vectorA.y) * 
           Math.sqrt(vectorB.x * vectorB.x + vectorB.y * vectorB.y))
        );

        // Determine the correct direction based on the cross product
        if (crossProduct >= 0) { // If cross product is positive, we're in the counterclockwise side
          alphaArcAngle = angleA + Math.PI * (config.alpha / 180);
          omegaArcAngle = angleA + Math.PI * (config.omega / 180);
        } else { // If cross product is negative, we're in the clockwise side
          alphaArcAngle = angleA - Math.PI * (config.alpha / 180);
          omegaArcAngle = angleA - Math.PI * (config.omega / 180);
        }
        
        // Calculate angle difference considering circle wrapping
        let angleDiff = omegaArcAngle - alphaArcAngle;
        if (angleDiff < 0) angleDiff += 2 * Math.PI;
        let isClockwise = angleDiff > Math.PI;

        
        
        // Draw target range arc
        ctx.beginPath();
        ctx.arc(
          middlePoint.x, 
          middlePoint.y, 
          radius + 20, 
          alphaArcAngle, 
          omegaArcAngle, 
          isClockwise
        );
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White with some transparency
        ctx.lineWidth = 6;
        ctx.stroke();
        
        // Draw skeleton lines with the joint's color
        ctx.strokeStyle = config.color;
        ctx.lineWidth = 3;
        
        // First segment
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(middlePoint.x, middlePoint.y);
        ctx.stroke();
        
        // Second segment
        ctx.beginPath();
        ctx.moveTo(middlePoint.x, middlePoint.y);
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.stroke();
        
        // Draw joint keypoints
        ctx.fillStyle = config.color;
        
        // Start point
        ctx.beginPath();
        ctx.arc(startPoint.x, startPoint.y, 5, 0, 2 * Math.PI);
        ctx.fill();
        
        // Middle point (slightly larger)
        ctx.beginPath();
        ctx.arc(middlePoint.x, middlePoint.y, 6, 0, 2 * Math.PI);
        ctx.fill();
        
        // End point
        ctx.beginPath();
        ctx.arc(endPoint.x, endPoint.y, 5, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw angle text near the joint if it's active
        if (config.active) {
          ctx.font = '24px Arial'; // Increased from 16px to 24px
          ctx.fillStyle = config.color;
          ctx.fillText(`${Math.round(config.smoothedAngle)}°`, middlePoint.x + 15, middlePoint.y - 15);
        }
        
        return true; // Indicate successful visualization
      }
      
      return false; // Indicate failed visualization
    }
    
    // Draw results on canvas
    function drawResults(ctx, poses, canvasWidth, canvasHeight) {
      // Clear the canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      if (!poses || poses.length === 0) {
        return; // Return early without drawing - message handling is now in detectAndRender
      }
      
      // Get the first detected pose
      const pose = poses[0];
      const keypoints = pose.keypoints;
      
      // Process each joint configured for tracking
      let successfulVisualizations = 0;
      
      for (const joint in jointConfig) {
        // Only process and visualize active joints
        if (jointConfig[joint].active) {
          const config = jointConfig[joint];
          const startPoint = keypoints[config.keypoints.start];
          const middlePoint = keypoints[config.keypoints.middle];
          const endPoint = keypoints[config.keypoints.end];
          
          // Check if we have all keypoints with good confidence
          if (startPoint && middlePoint && endPoint && 
              startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
            
            // Calculate the angle
            const angle = calculateAngle(startPoint, middlePoint, endPoint);
            
            // Store the raw angle
            config.currentAngle = angle;
            
            // Apply smoothing
            config.smoothedAngle = smoothAngle(angle, config.smoothedAngle, smoothingFactor);
            
            // Draw the visualization
            if (drawAngleVisualization(ctx, joint, keypoints)) {
              successfulVisualizations++;
            }
          }
        }
      }
      
      // If no joint was successfully visualized, show a message
      if (successfulVisualizations === 0) {
        return; // Return early without drawing - message handling is now in detectAndRender
      }
    }
    
    // Update UI elements
    function updateUI() {
      // Update angle displays for all active joints
      updateAngleDisplays();
      
      // REP COUNTING LOGIC - Process each active joint
      for (const joint in jointConfig) {
        if (jointConfig[joint].active) {
          const config = jointConfig[joint];
          const angle = config.smoothedAngle; // Use smoothed angle instead of raw angle
          
          const isAtAlpha = isAngleCloseToTarget(angle, config.alpha, angleTolerance);
          const isAtOmega = isAngleCloseToTarget(angle, config.omega, angleTolerance);
          
          // If we're at omega and haven't counted this rep yet, and we're ready for next rep
          if (isAtOmega && !config.hasReachedOmega && config.isReadyForNextRep) {
            config.hasReachedOmega = true;
            config.repCount++;
            updateRepCounter();
            config.isReadyForNextRep = false; // Now we need to go back to alpha
          }
          
          // If we're back at alpha after reaching omega, we're ready for the next rep
          if (isAtAlpha && config.hasReachedOmega && !config.isReadyForNextRep) {
            config.hasReachedOmega = false; // Reset for next rep
            config.isReadyForNextRep = true;
          }
        }
      }
    }
    
    // Add this function after the smoothAngle function
    function smoothKeypoints(currentKeypoints, previousKeypoints) {
      if (!previousKeypoints || !currentKeypoints) return currentKeypoints;
      
      // Create a deep copy of current keypoints to avoid modifying the original
      const smoothedKeypoints = JSON.parse(JSON.stringify(currentKeypoints));
      
      // Apply smoothing to each keypoint
      for (let i = 0; i < smoothedKeypoints.length; i++) {
        if (previousKeypoints[i] && smoothedKeypoints[i]) {
          // Only smooth if confidence is good
          if (smoothedKeypoints[i].score > 0.3) {
            smoothedKeypoints[i].x = positionSmoothingFactor * previousKeypoints[i].x + 
                                   (1 - positionSmoothingFactor) * smoothedKeypoints[i].x;
            smoothedKeypoints[i].y = positionSmoothingFactor * previousKeypoints[i].y + 
                                   (1 - positionSmoothingFactor) * smoothedKeypoints[i].y;
          }
        }
      }
      
      return smoothedKeypoints;
    }
    
    // Create a variable to store the previous keypoints
    let previousKeypoints = null;
    
    // Main detection and rendering loop
    async function detectAndRender() {
      if (!isRunning) return;
      
      try {
        // Set canvas dimensions to match video
        canvasEl.width = webcamEl.width;
        canvasEl.height = webcamEl.height;
        
        // Clear the canvas with transparent background
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        
        // Detect poses
        const poses = await detector.estimatePoses(webcamEl);
        
        // Check if any valid pose was detected
        let validPoseDetected = false;
        
        if (poses && poses.length > 0) {
          // Mirror the pose data
          poses.forEach(pose => {
            if (pose.keypoints && pose.keypoints.length > 0) {
              // Mirror the x coordinates
              pose.keypoints.forEach(keypoint => {
                keypoint.x = canvasEl.width - keypoint.x;
              });
              
              // Apply smoothing to keypoints
              pose.keypoints = smoothKeypoints(pose.keypoints, previousKeypoints);
              
              // Store current keypoints for next frame
              previousKeypoints = JSON.parse(JSON.stringify(pose.keypoints));
              
              // Check if we have enough valid keypoints for visualization
              let validKeypointsCount = 0;
              for (const joint in jointConfig) {
                if (jointConfig[joint].active) {
                  const config = jointConfig[joint];
                  const startPoint = pose.keypoints[config.keypoints.start];
                  const middlePoint = pose.keypoints[config.keypoints.middle];
                  const endPoint = pose.keypoints[config.keypoints.end];
                  
                  if (startPoint && middlePoint && endPoint && 
                      startPoint.score > 0.3 && middlePoint.score > 0.3 && endPoint.score > 0.3) {
                    validKeypointsCount++;
                  }
                }
              }
              
              if (validKeypointsCount > 0) {
                validPoseDetected = true;
                lastValidPoseTime = Date.now();
              }
            }
          });
        }
        
        // Now draw results and check if we need to show the message
        if (validPoseDetected) {
          drawResults(ctx, poses, canvasEl.width, canvasEl.height);
          updateUI();
        } else {
          // Check if we should show the message or keep the last pose
          const currentTime = Date.now();
          if (currentTime - lastValidPoseTime > messageDelayThreshold) {
            // Show the message if we've waited long enough
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('Position your body clearly in view', canvasEl.width / 2, canvasEl.height / 2);
          } else if (previousKeypoints) {
            // Create a fake pose with the previous keypoints to keep displaying
            const fakePose = { keypoints: previousKeypoints };
            drawResults(ctx, [fakePose], canvasEl.width, canvasEl.height);
            updateUI();
          }
        }
        
        // Continue the loop
        requestAnimationFrame(detectAndRender);
      } catch (error) {
        console.error("Error in pose detection:", error);
        statusMessageEl.textContent = "Error: " + error.message;
        stopDetection();
      }
    }
    
    // Function to stop detection
    function stopDetection() {
      isRunning = false;
      // Additional cleanup if needed
    }
    
    // Start tracking
    async function startTracking() {
      try {
        // Hide the start button and show loading
        startButtonEl.style.display = 'none';
        loadingEl.style.display = 'flex';
        statusMessageEl.textContent = 'Setting up webcam...';
        
        // Setup webcam
        await setupWebcam();
        
        // Load pose model
        statusMessageEl.textContent = 'Loading pose detection model...';
        detector = await loadPoseDetectionModel();
        
        // Hide loading screen, show webcam
        loadingEl.style.display = 'none';
        webcamEl.style.display = 'block'; // Make sure webcam is visible
        
        // Create initial angle displays
        createAngleDisplays();
        
        // Start the detection loop
        isRunning = true;
        detectAndRender();
      } catch (error) {
        console.error('Error starting tracking:', error);
        statusMessageEl.textContent = 'Error starting tracking: ' + error.message;
        startButtonEl.style.display = 'block';
      }
    }
    
    // Initialize the app
    async function init() {
      try {
        // Check if TensorFlow.js is available
        if (typeof tf === 'undefined') {
          statusMessageEl.textContent = 'TensorFlow.js not loaded. Check your internet connection.';
          return;
        }
        
        // Show start button
        statusMessageEl.textContent = 'Ready to start. Click the button below.';
        startButtonEl.style.display = 'block';
        startButtonEl.addEventListener('click', startTracking);
        
        // Initialize rep counter
        updateRepCounter();
      } catch (error) {
        console.error('Initialization error:', error);
        statusMessageEl.textContent = 'Initialization error: ' + error.message;
      }
    }
    
    // Start when page is loaded
    window.onload = init;
  </script>
</body>
</html>